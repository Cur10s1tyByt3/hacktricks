# Relro

{{#include ../../banners/hacktricks-training.md}}

## Relro

**RELRO** significa **Relocation Read-Only** y es una mitigaci√≥n implementada por el enlazador (`ld`) que convierte un subconjunto de los segmentos de datos del ELF en **solo lectura despu√©s de que se hayan aplicado todas las reubicaciones**. El objetivo es evitar que un atacante sobrescriba entradas en la **GOT (Tabla de Desplazamiento Global)** u otras tablas relacionadas con la reubicaci√≥n que se desreferencian durante la ejecuci√≥n del programa (por ejemplo, `__fini_array`).

Los enlazadores modernos implementan RELRO al **reordenar** la **GOT** (y algunas otras secciones) para que vivan **antes** de la **.bss** y, lo m√°s importante, creando un segmento dedicado `PT_GNU_RELRO` que se remapea `R‚ÄìX` justo despu√©s de que el cargador din√°mico termina de aplicar las reubicaciones. En consecuencia, los desbordamientos de b√∫fer t√≠picos en la **.bss** ya no pueden alcanzar la GOT y las primitivas de escritura arbitraria no pueden usarse para sobrescribir punteros de funci√≥n que se encuentran dentro de una p√°gina protegida por RELRO.

Hay **dos niveles** de protecci√≥n que el enlazador puede emitir:

### Partial RELRO

* Producido con la bandera `-Wl,-z,relro` (o simplemente `-z relro` al invocar `ld` directamente).
* Solo la parte **no-PLT** de la **GOT** (la parte utilizada para reubicaciones de datos) se coloca en el segmento de solo lectura. Las secciones que necesitan ser modificadas en tiempo de ejecuci√≥n ‚Äì lo m√°s importante **.got.plt** que soporta **lazy binding** ‚Äì permanecen escribibles.
* Debido a eso, una primitiva de **escritura arbitraria** a√∫n puede redirigir el flujo de ejecuci√≥n sobrescribiendo una entrada PLT (o realizando **ret2dlresolve**).
* El impacto en el rendimiento es negligible y, por lo tanto, **casi todas las distribuciones han estado enviando paquetes con al menos Partial RELRO durante a√±os (es el valor predeterminado de GCC/Binutils desde 2016)**.

### Full RELRO

* Producido con **ambas** banderas `-Wl,-z,relro,-z,now` (tambi√©n conocido como `-z relro -z now`). `-z now` obliga al cargador din√°mico a resolver **todos** los s√≠mbolos de antemano (vinculaci√≥n ansiosa) para que **.got.plt** nunca necesite ser escrita nuevamente y pueda ser mapeada de forma segura como solo lectura.
* Toda la **GOT**, **.got.plt**, **.fini_array**, **.init_array**, **.preinit_array** y algunas tablas internas adicionales de glibc terminan dentro de un segmento `PT_GNU_RELRO` de solo lectura.
* Agrega una sobrecarga de inicio medible (todas las reubicaciones din√°micas se procesan al inicio) pero **sin sobrecarga en tiempo de ejecuci√≥n**.

Desde 2023, varias distribuciones principales han cambiado a compilar la **cadena de herramientas del sistema** (y la mayor√≠a de los paquetes) con **Full RELRO por defecto** ‚Äì por ejemplo, **Debian 12 ‚Äúbookworm‚Äù (dpkg-buildflags 13.0.0)** y **Fedora 35+**. Como pentester, por lo tanto, deber√≠as esperar encontrar binarios donde **cada entrada de la GOT es de solo lectura**.

---

## C√≥mo verificar el estado de RELRO de un binario
```bash
$ checksec --file ./vuln
[*] '/tmp/vuln'
Arch:     amd64-64-little
RELRO:    Full
Stack:    Canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```
`checksec` (parte de [pwntools](https://github.com/pwncollege/pwntools) y muchas distribuciones) analiza los encabezados de `ELF` y muestra el nivel de protecci√≥n. Si no puedes usar `checksec`, conf√≠a en `readelf`:
```bash
# Partial RELRO ‚Üí PT_GNU_RELRO is present but BIND_NOW is *absent*
$ readelf -l ./vuln | grep -E "GNU_RELRO|BIND_NOW"
GNU_RELRO      0x0000000000600e20 0x0000000000600e20
```

```bash
# Full RELRO ‚Üí PT_GNU_RELRO *and* the DF_BIND_NOW flag
$ readelf -d ./vuln | grep BIND_NOW
0x0000000000000010 (FLAGS)              FLAGS: BIND_NOW
```
Si el binario est√° en ejecuci√≥n (por ejemplo, un helper con set-uid root), a√∫n puedes inspeccionar el ejecutable **a trav√©s de `/proc/$PID/exe`**:
```bash
readelf -l /proc/$(pgrep helper)/exe | grep GNU_RELRO
```
---

## Habilitando RELRO al compilar tu propio c√≥digo
```bash
# GCC example ‚Äì create a PIE with Full RELRO and other common hardenings
$ gcc -fPIE -pie -z relro -z now -Wl,--as-needed -D_FORTIFY_SOURCE=2 main.c -o secure
```
`-z relro -z now` funciona para ambos **GCC/clang** (pasado despu√©s de `-Wl,`) y **ld** directamente. Al usar **CMake 3.18+** puedes solicitar Full RELRO con el preset incorporado:
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON) # LTO
set(CMAKE_ENABLE_EXPORTS OFF)
set(CMAKE_BUILD_RPATH_USE_ORIGIN ON)
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-z,relro,-z,now")
```
---

## T√©cnicas de Bypass

| Nivel de RELRO | Primitiva t√≠pica | Posibles t√©cnicas de explotaci√≥n |
|----------------|-------------------|----------------------------------|
| Ninguno / Parcial | Escritura arbitraria | 1. Sobrescribir la entrada de **.got.plt** y pivotar la ejecuci√≥n.<br>2. **ret2dlresolve** ‚Äì crear un `Elf64_Rela` y `Elf64_Sym` falsos en un segmento escribible y llamar a `_dl_runtime_resolve`.<br>3. Sobrescribir punteros de funci√≥n en **.fini_array** / lista de **atexit()**. |
| Completo | GOT es de solo lectura | 1. Buscar **otros punteros de c√≥digo escribibles** (vtables de C++, `__malloc_hook` < glibc 2.34, `__free_hook`, callbacks en secciones `.data` personalizadas, p√°ginas JIT).<br>2. Abusar de primitivas de *lectura relativa* para filtrar libc y realizar **SROP/ROP en libc**.<br>3. Inyectar un objeto compartido malicioso a trav√©s de **DT_RPATH**/`LD_PRELOAD` (si el entorno est√° controlado por el atacante) o **`ld_audit`**.<br>4. Explotar **format-string** o sobrescritura parcial de punteros para desviar el flujo de control sin tocar el GOT. |

> üí° Incluso con Full RELRO, el **GOT de las bibliotecas compartidas cargadas (por ejemplo, libc misma)** es **solo RELRO Parcial** porque esos objetos ya est√°n mapeados cuando el cargador aplica las reubicaciones. Si obtienes una primitiva de **escritura arbitraria** que puede dirigirse a las p√°ginas de otro objeto compartido, a√∫n puedes pivotar la ejecuci√≥n sobrescribiendo las entradas del GOT de libc o la pila de `__rtld_global`, una t√©cnica que se explota regularmente en desaf√≠os modernos de CTF.

### Ejemplo de bypass en el mundo real (CTF 2024 ‚Äì *pwn.college ‚Äúenlightened‚Äù*)

El desaf√≠o se envi√≥ con Full RELRO. La explotaci√≥n utiliz√≥ un **off-by-one** para corromper el tama√±o de un fragmento de heap, filtr√≥ libc con `tcache poisoning` y finalmente sobrescribi√≥ `__free_hook` (fuera del segmento RELRO) con un one-gadget para obtener ejecuci√≥n de c√≥digo. No se requiri√≥ escritura en el GOT.

---

## Investigaci√≥n reciente y vulnerabilidades (2022-2025)

* **glibc 2.40 depreca `__malloc_hook` / `__free_hook` (2025)** ‚Äì La mayor√≠a de las explotaciones modernas de heap que abusaron de estos s√≠mbolos deben pivotar ahora a vectores alternativos como **`rtld_global._dl_load_jump`** o tablas de excepciones de C++. Debido a que los hooks viven **fuera** de RELRO, su eliminaci√≥n aumenta la dificultad de los bypasses de Full-RELRO.
* **Correcci√≥n de ‚Äúmax-page-size‚Äù de Binutils 2.41 (2024)** ‚Äì Un error permiti√≥ que los √∫ltimos bytes del segmento RELRO compartieran una p√°gina con datos escribibles en algunas compilaciones de ARM64, dejando un peque√±o **hueco RELRO** que podr√≠a escribirse despu√©s de `mprotect`. Ahora, el upstream alinea `PT_GNU_RELRO` a los l√≠mites de p√°gina, eliminando ese caso l√≠mite.

---

## Referencias

* Documentaci√≥n de Binutils ‚Äì *`-z relro`, `-z now` y `PT_GNU_RELRO`*
* *‚ÄúRELRO ‚Äì Full, Partial and Bypass Techniques‚Äù* ‚Äì publicaci√≥n en el blog @ wolfslittlered 2023

{{#include ../../banners/hacktricks-training.md}}
