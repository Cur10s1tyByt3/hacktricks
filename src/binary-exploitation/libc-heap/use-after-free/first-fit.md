# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Cuando liberas memoria en un programa usando glibc, se utilizan diferentes "bins" para gestionar los bloques de memoria. Aqu√≠ hay una explicaci√≥n simplificada de dos escenarios comunes: bins no ordenados y fastbins.

### Bins No Ordenados

Cuando liberas un bloque de memoria que no es un bloque r√°pido, va al bin no ordenado. Este bin act√∫a como una lista donde los nuevos bloques liberados se a√±aden al frente (la "cabeza"). Cuando solicitas un nuevo bloque de memoria, el asignador mira el bin no ordenado desde la parte trasera (la "cola") para encontrar un bloque que sea lo suficientemente grande. Si un bloque del bin no ordenado es m√°s grande de lo que necesitas, se divide, devolviendo la parte delantera y manteniendo la parte restante en el bin.

Ejemplo:

- Asignas 300 bytes (`a`), luego 250 bytes (`b`), luego liberas `a` y solicitas nuevamente 250 bytes (`c`).
- Cuando liberas `a`, va al bin no ordenado.
- Si luego solicitas 250 bytes nuevamente, el asignador encuentra `a` en la cola y lo divide, devolviendo la parte que se ajusta a tu solicitud y manteniendo el resto en el bin.
- `c` apuntar√° al anterior `a` y estar√° lleno con el contenido de `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se utilizan para peque√±os fragmentos de memoria. A diferencia de los bins no ordenados, los fastbins a√±aden nuevos fragmentos a la cabeza, creando un comportamiento de √∫ltimo en entrar, primero en salir (LIFO). Si solicitas un peque√±o fragmento de memoria, el asignador tomar√° de la cabeza del fastbin.

Ejemplo:
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### üî• Consideraciones modernas de glibc (tcache ‚â• 2.26)

Desde glibc 2.26, cada hilo mantiene su propio **tcache** que se consulta *antes* del contenedor no ordenado. Por lo tanto, un escenario de primer ajuste **solo se alcanzar√° si**:

1. El tama√±o solicitado es **mayor que `tcache_max`** (0x420 en 64 bits por defecto), *o*
2. El contenedor tcache correspondiente est√° **ya lleno o vaciado manualmente** (al asignar 7 elementos y mantenerlos en uso).

En exploits reales, generalmente agregar√°s una rutina auxiliar como:
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Una vez que el tcache est√° agotado, las liberaciones subsiguientes van al contenedor no ordenado y se puede activar nuevamente el comportamiento cl√°sico de primer ajuste (b√∫squeda desde el final, inserci√≥n en la cabeza).

---
### üö© Creando un UAF de chunk superpuesto con primer ajuste

El fragmento a continuaci√≥n (probado en glibc 2.38) muestra c√≥mo se puede abusar del divisor en el contenedor no ordenado para crear 2 **punteros superpuestos** ‚Äì un primitivo poderoso que convierte una √∫nica liberaci√≥n en una escritura despu√©s de la liberaci√≥n.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A ‚Üí unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B ‚Äì creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Receta de explotaci√≥n (com√∫n en CTF recientes):

1. **Drenar** el tcache para el tama√±o objetivo.
2. **Liberar** un chunk para que caiga en el contenedor no ordenado.
3. **Asignar** un tama√±o ligeramente menor ‚Äì el asignador divide el chunk no ordenado.
4. **Asignar** de nuevo ‚Äì la parte sobrante se superpone con un chunk existente en uso ‚Üí UAF.
5. Sobrescribir campos sensibles (punteros de funci√≥n, vtable de FILE, etc.)

Una aplicaci√≥n pr√°ctica se puede encontrar en el desaf√≠o *Setjmp* de las Quals de HITCON 2024 donde se utiliza este primitivo exacto para pivotar de un UAF a control total de `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### üõ°Ô∏è  Mitigaciones y Endurecimiento

* **Safe-linking (glibc ‚â• 2.32)** solo protege las listas de *tcache*/**fastbin** enlazadas de forma simple. Los contenedores no ordenados/peque√±os/grandes a√∫n almacenan punteros en bruto, por lo que las superposiciones basadas en el primer ajuste siguen siendo viables si puedes obtener un leak de heap.
* **Cifrado de punteros de heap y MTE** (ARM64) a√∫n no afectan a glibc x86-64, pero las banderas de endurecimiento de distribuciones como `GLIBC_TUNABLES=glibc.malloc.check=3` abortar√°n en metadatos inconsistentes y pueden romper PoCs ingenuas.
* **Llenar tcache al liberar** (propuesto en 2024 para glibc 2.41) reducir√≠a a√∫n m√°s el uso no ordenado; monitorea futuras versiones al desarrollar exploits gen√©ricos.

---
## Otras Referencias y Ejemplos

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Uso despu√©s de liberar: Generar un objeto de usuario, liberarlo, generar un objeto que obtenga el chunk liberado y permitir escribir en √©l, **sobrescribiendo la posici√≥n de user->password** del anterior. Reutilizar el usuario para **eludir la verificaci√≥n de contrase√±a**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- El programa permite crear notas. Una nota tendr√° la informaci√≥n de la nota en un malloc(8) (con un puntero a una funci√≥n que podr√≠a ser llamada) y un puntero a otro malloc(<size>) con el contenido de la nota.
- El ataque consistir√≠a en crear 2 notas (note0 y note1) con contenidos de malloc m√°s grandes que el tama√±o de la informaci√≥n de la nota y luego liberarlas para que entren en el fast bin (o tcache).
- Luego, crear otra nota (note2) con un tama√±o de contenido de 8. El contenido estar√° en note1 ya que el chunk se reutilizar√°, donde podr√≠amos modificar el puntero de funci√≥n para apuntar a la funci√≥n ganadora y luego usar el Use-After-Free en note1 para llamar al nuevo puntero de funci√≥n.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Es posible asignar algo de memoria, escribir el valor deseado, liberarlo, reasignarlo y como los datos anteriores a√∫n est√°n all√≠, se tratar√° seg√∫n la nueva estructura esperada en el chunk, lo que hace posible establecer el valor para obtener la bandera.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- En este caso, es necesario escribir 4 dentro de un chunk espec√≠fico que es el primero que se asigna (incluso despu√©s de forzar la liberaci√≥n de todos ellos). En cada nuevo chunk asignado, su n√∫mero en el √≠ndice del array se almacena. Luego, asignar 4 chunks (+ el inicialmente asignado), el √∫ltimo tendr√° 4 dentro de √©l, liberarlos y forzar la reasignaci√≥n del primero, que utilizar√° el √∫ltimo chunk liberado que es el que tiene 4 dentro de √©l.
- Resumen de las Quals de HITCON 2024 Setjmp (Quarkslab) ‚Äì ataque pr√°ctico de superposici√≥n de primer ajuste / divisi√≥n no ordenada: <https://ctftime.org/writeup/39355>
- Resumen de Angstrom CTF 2024 *heapify* ‚Äì abusando de la divisi√≥n de contenedores no ordenados para filtrar libc y obtener superposici√≥n: <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
