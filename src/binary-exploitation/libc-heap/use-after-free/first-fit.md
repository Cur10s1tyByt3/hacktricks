# First Fit

{{#include ../../../banners/hacktricks-training.md}}

## **First Fit**

Lorsque vous lib√©rez de la m√©moire dans un programme utilisant glibc, diff√©rents "bins" sont utilis√©s pour g√©rer les morceaux de m√©moire. Voici une explication simplifi√©e de deux sc√©narios courants : les bins non tri√©s et les fastbins.

### Bins Non Tri√©s

Lorsque vous lib√©rez un morceau de m√©moire qui n'est pas un morceau rapide, il va dans le bin non tri√©. Ce bin agit comme une liste o√π les nouveaux morceaux lib√©r√©s sont ajout√©s √† l'avant (la "t√™te"). Lorsque vous demandez un nouveau morceau de m√©moire, l'allocateur examine le bin non tri√© depuis l'arri√®re (la "queue") pour trouver un morceau suffisamment grand. Si un morceau du bin non tri√© est plus grand que ce dont vous avez besoin, il est divis√©, la partie avant √©tant retourn√©e et la partie restante restant dans le bin.

Exemple :

- Vous allouez 300 octets (`a`), puis 250 octets (`b`), puis lib√©rez `a` et demandez √† nouveau 250 octets (`c`).
- Lorsque vous lib√©rez `a`, il va dans le bin non tri√©.
- Si vous demandez √† nouveau 250 octets, l'allocateur trouve `a` √† la queue et le divise, retournant la partie qui correspond √† votre demande et gardant le reste dans le bin.
- `c` pointera vers l'ancien `a` et sera rempli avec le contenu de `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Les fastbins sont utilis√©s pour de petits morceaux de m√©moire. Contrairement aux unsorted bins, les fastbins ajoutent de nouveaux morceaux au d√©but, cr√©ant un comportement de dernier entr√©, premier sorti (LIFO). Si vous demandez un petit morceau de m√©moire, l'allocateur prendra √† partir du d√©but du fastbin.

Exemple :
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
---
### üî• Consid√©rations modernes sur glibc (tcache ‚â• 2.26)

Depuis glibc 2.26, chaque thread conserve son propre **tcache** qui est interrog√© *avant* le bin non tri√©. Par cons√©quent, un sc√©nario de premier ajustement ne sera **atteint que si** :

1. La taille demand√©e est **plus grande que `tcache_max`** (0x420 sur 64 bits par d√©faut), *ou*
2. Le bin tcache correspondant est **d√©j√† plein ou vid√© manuellement** (en allouant 7 √©l√©ments et en les maintenant en usage).

Dans les exploits r√©els, vous ajouterez g√©n√©ralement une routine d'assistance telle que :
```c
// Drain the tcache for a given size
for(int i = 0; i < 7; i++) pool[i] = malloc(0x100);
for(int i = 0; i < 7; i++) free(pool[i]);
```
Une fois que le tcache est √©puis√©, les lib√©rations suivantes vont dans le bin non tri√© et le comportement classique de premier ajustement (recherche √† la fin, insertion √† la t√™te) peut √™tre d√©clench√© √† nouveau.

---
### üö© Cr√©ation d'un UAF de chunk chevauchant avec premier ajustement

Le fragment ci-dessous (test√© sur glibc 2.38) montre comment le diviseur dans le bin non tri√© peut √™tre abus√© pour cr√©er 2 **pointeurs chevauchants** ‚Äì un puissant primitif qui convertit une seule lib√©ration en √©criture apr√®s lib√©ration.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
setbuf(stdout, NULL);

/* 1. prepare 2 adjacent chunks and free the first one */
char *A = malloc(0x420);   // big enough to bypass tcache
char *B = malloc(0x420);
strcpy(A, "AAAA\n");
free(A);                   // A ‚Üí unsorted

/* 2. request a *smaller* size to force a split of A */
char *C = malloc(0x400);   // returns lower half of former A

/* 3. The remainder of A is still in the unsorted bin.
Another 0x400-byte malloc will now return the *same*
region pointed to by B ‚Äì creating a UAF/overlap. */
char *C2 = malloc(0x400);

printf("B  = %p\nC2 = %p (overlaps B)\n", B, C2);

// Arbitrary write in B is immediately visible via C2
memset(B, 'X', 0x10);
fwrite(C2, 1, 0x10, stdout);  // prints Xs
}
```
Recette d'exploitation (courante dans les CTF r√©cents) :

1. **Vider** le tcache pour la taille cible.
2. **Lib√©rer** un chunk pour qu'il atterrisse dans le bin non tri√©.
3. **Allouer** une taille l√©g√®rement plus petite ‚Äì l'allocateur divise le chunk non tri√©.
4. **Allouer** √† nouveau ‚Äì la partie restante chevauche un chunk existant en cours d'utilisation ‚Üí UAF.
5. √âcraser des champs sensibles (pointeurs de fonction, vtable de FILE, etc.)

Une application pratique peut √™tre trouv√©e dans le d√©fi *Setjmp* des qualifications HITCON 2024 o√π ce primitif exact est utilis√© pour pivoter d'un UAF √† un contr√¥le total de `__free_hook`.{{#ref}}
../../../../references/2024_setjmp_firstfit.md
{{#endref}}

---
### üõ°Ô∏è  Att√©nuations & Renforcement

* **Safe-linking (glibc ‚â• 2.32)** prot√®ge uniquement les listes *tcache*/**fastbin** √† liaison simple. Les bins non tri√©s/petits/grands stockent toujours des pointeurs bruts, donc les chevauchements bas√©s sur le premier ajustement restent viables si vous pouvez obtenir une fuite de heap.
* **Chiffrement des pointeurs de heap & MTE** (ARM64) n'affectent pas encore glibc x86-64, mais des drapeaux de durcissement de distribution tels que `GLIBC_TUNABLES=glibc.malloc.check=3` provoqueront une interruption en cas de m√©tadonn√©es incoh√©rentes et peuvent casser des PoCs na√Øfs.
* **Remplissage du tcache √† la lib√©ration** (propos√© en 2024 pour glibc 2.41) r√©duirait encore l'utilisation non tri√©e ; surveillez les futures versions lors du d√©veloppement d'exploits g√©n√©riques.

---
## Autres R√©f√©rences & Exemples

- [**https://heap-exploitation.dhavalkapil.com/attacks/first_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first_fit)
- [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
- ARM64. Utilisation apr√®s lib√©ration : G√©n√©rer un objet utilisateur, le lib√©rer, g√©n√©rer un objet qui obtient le chunk lib√©r√© et permet d'√©crire dessus, **√©crasant la position de user->password** de l'ancien. R√©utiliser l'utilisateur pour **contourner la v√©rification du mot de passe**
- [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use_after_free/#example)
- Le programme permet de cr√©er des notes. Une note aura les informations de la note dans un malloc(8) (avec un pointeur vers une fonction qui pourrait √™tre appel√©e) et un pointeur vers un autre malloc(<size>) avec le contenu de la note.
- L'attaque consisterait √† cr√©er 2 notes (note0 et note1) avec des contenus malloc plus grands que la taille des informations de la note, puis √† les lib√©rer pour qu'elles entrent dans le fast bin (ou tcache).
- Ensuite, cr√©er une autre note (note2) avec une taille de contenu de 8. Le contenu sera dans note1 car le chunk va √™tre r√©utilis√©, o√π nous pourrions modifier le pointeur de fonction pour pointer vers la fonction win et ensuite utiliser l'usage apr√®s lib√©ration de note1 pour appeler le nouveau pointeur de fonction.
- [**https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/pico_areyouroot/index.html)
- Il est possible d'allouer de la m√©moire, d'√©crire la valeur souhait√©e, de la lib√©rer, de la r√©allouer et comme les donn√©es pr√©c√©dentes sont toujours l√†, elles seront trait√©es selon la nouvelle structure attendue dans le chunk, rendant possible de d√©finir la valeur pour obtenir le flag.
- [**https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap_grooming/swamp19_heapgolf/index.html)
- Dans ce cas, il est n√©cessaire d'√©crire 4 √† l'int√©rieur d'un chunk sp√©cifique qui est le premier allou√© (m√™me apr√®s avoir forc√© la lib√©ration de tous). √Ä chaque nouveau chunk allou√©, son num√©ro dans l'index du tableau est stock√©. Ensuite, allouer 4 chunks (+ le premier allou√©), le dernier contiendra 4 √† l'int√©rieur, les lib√©rer et forcer la r√©allocation du premier, qui utilisera le dernier chunk lib√©r√©, celui avec 4 √† l'int√©rieur.
- R√©cit des qualifications HITCON 2024 Setjmp (Quarkslab) ‚Äì attaque pratique de chevauchement premier ajustement / non tri√© : <https://ctftime.org/writeup/39355>
- R√©cit de l'Angstrom CTF 2024 *heapify* ‚Äì abus de la division du bin non tri√© pour fuir libc et obtenir un chevauchement : <https://hackmd.io/@aneii11/H1S2snV40>

{{#include ../../../banners/hacktricks-training.md}}
