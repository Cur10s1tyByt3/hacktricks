# Desbordamiento de Heap

{{#include ../../banners/hacktricks-training.md}}

## Información Básica

Un desbordamiento de heap es como un [**desbordamiento de pila**](../stack-overflow/index.html) pero en el heap. Básicamente significa que se reservó un espacio en el heap para almacenar algunos datos y **los datos almacenados eran más grandes que el espacio reservado.**

En los desbordamientos de pila sabemos que algunos registros como el puntero de instrucción o el marco de pila se van a restaurar desde la pila y podría ser posible abusar de esto. En el caso de los desbordamientos de heap, **no hay información sensible almacenada por defecto** en el bloque de heap que puede ser desbordado. Sin embargo, podría haber información sensible o punteros, por lo que la **criticidad** de esta vulnerabilidad **depende** de **qué datos podrían ser sobrescritos** y cómo un atacante podría abusar de esto.

> [!TIP]
> Para encontrar los desplazamientos de desbordamiento, puedes usar los mismos patrones que en [**desbordamientos de pila**](../stack-overflow/index.html#finding-stack-overflows-offsets).

### Desbordamientos de Pila vs Desbordamientos de Heap

En los desbordamientos de pila, la disposición y los datos que van a estar presentes en la pila en el momento en que se puede activar la vulnerabilidad son bastante confiables. Esto se debe a que la pila es lineal, siempre aumentando en memoria colisionante, en **lugares específicos de la ejecución del programa la memoria de la pila generalmente almacena un tipo de datos similar** y tiene una estructura específica con algunos punteros al final de la parte de la pila utilizada por cada función.

Sin embargo, en el caso de un desbordamiento de heap, la memoria utilizada no es lineal, sino que **los bloques asignados suelen estar en posiciones separadas de la memoria** (no uno al lado del otro) debido a **bins y zonas** que separan las asignaciones por tamaño y porque **la memoria previamente liberada se utiliza** antes de asignar nuevos bloques. Es **complicado saber el objeto que va a colisionar con el que es vulnerable** a un desbordamiento de heap. Por lo tanto, cuando se encuentra un desbordamiento de heap, es necesario encontrar una **manera confiable de hacer que el objeto deseado esté al lado en memoria** del que puede ser desbordado.

Una de las técnicas utilizadas para esto es **Heap Grooming**, que se utiliza por ejemplo [**en esta publicación**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). En la publicación se explica cómo, cuando en el kernel de iOS una zona se queda sin memoria para almacenar bloques de memoria, se expande por una página del kernel, y esta página se divide en bloques de los tamaños esperados que se utilizarían en orden (hasta la versión 9.2 de iOS, luego estos bloques se utilizan de manera aleatoria para dificultar la explotación de estos ataques).

Por lo tanto, en la publicación anterior donde ocurre un desbordamiento de heap, para forzar que el objeto desbordado colisione con un objeto víctima, se **forzan varios `kallocs` por varios hilos para intentar asegurar que todos los bloques libres estén llenos y que se cree una nueva página**.

Para forzar este llenado con objetos de un tamaño específico, la **asignación fuera de línea asociada con un puerto mach de iOS** es un candidato ideal. Al elaborar el tamaño del mensaje, es posible especificar exactamente el tamaño de la asignación `kalloc` y cuando el puerto mach correspondiente se destruye, la asignación correspondiente se liberará inmediatamente de nuevo a `kfree`.

Luego, algunos de estos marcadores de posición pueden ser **liberados**. La **lista libre `kalloc.4096` libera elementos en un orden de último en entrar, primero en salir**, lo que básicamente significa que si algunos marcadores de posición son liberados y el exploit intenta asignar varios objetos víctima mientras intenta asignar el objeto vulnerable al desbordamiento, es probable que este objeto sea seguido por un objeto víctima.

### Ejemplo libc

[**En esta página**](https://guyinatuxedo.github.io/27-edit_free_chunk/heap_consolidation_explanation/index.html) es posible encontrar una emulación básica de desbordamiento de heap que muestra cómo sobrescribir el bit de prev en uso del siguiente bloque y la posición del tamaño previo es posible **consolidar un bloque usado** (haciéndolo pensar que está sin usar) y **luego asignarlo nuevamente** pudiendo sobrescribir datos que están siendo utilizados en un puntero diferente también.

Otro ejemplo de [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap0/index.html) muestra un ejemplo muy básico de un CTF donde un **desbordamiento de heap** puede ser abusado para llamar a la función ganadora para **obtener la bandera**.

En el ejemplo de [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap_overflow/protostar_heap1/index.html) es posible ver cómo abusando de un desbordamiento de búfer es posible **sobrescribir en un bloque cercano una dirección** donde **se van a escribir datos arbitrarios del usuario**.

### Ejemplo ARM64

En la página [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) puedes encontrar un ejemplo de desbordamiento de heap donde un comando que se va a ejecutar se almacena en el siguiente bloque del bloque desbordado. Así, es posible modificar el comando ejecutado sobrescribiéndolo con un exploit fácil como:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Otros ejemplos

- [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
- Usamos una vulnerabilidad de desbordamiento de entero para obtener un desbordamiento de heap.
- Corrompemos punteros a una función dentro de un `struct` del chunk desbordado para establecer una función como `system` y obtener ejecución de código.

### Ejemplo del mundo real: CVE-2025-40597 – Uso indebido de `__sprintf_chk`

En el firmware 10.2.1.15 de SonicWall SMA100, el módulo de reverse-proxy `mod_httprp.so` asigna un chunk de heap de **0x80 bytes** y luego concatena varias cadenas en él con `__sprintf_chk`:
```c
char *buf = calloc(0x80, 1);
/* … */
__sprintf_chk(buf,               /* destination (0x80-byte chunk) */
-1,                /* <-- size argument   !!! */
0,                 /* flags */
"%s%s%s%s",      /* format */
"/", "https://", path, host);
```
`__sprintf_chk` es parte de **_FORTIFY_SOURCE**. Cuando recibe un parámetro de `size` **positivo**, verifica que la cadena resultante quepa dentro del búfer de destino. Al pasar **`-1` (0xFFFFFFFFFFFFFFFF)**, los desarrolladores efectivamente **deshabilitaron la verificación de límites**, convirtiendo la llamada reforzada de nuevo en un `sprintf` clásico y no seguro.

Por lo tanto, proporcionar un encabezado **`Host:`** excesivamente largo permite a un atacante **desbordar el chunk de 0x80 bytes y sobrescribir los metadatos del siguiente chunk de heap** (tcache / fast-bin / small-bin dependiendo del asignador). Se puede reproducir un fallo con:
```python
import requests, warnings
warnings.filterwarnings('ignore')
requests.get(
'https://TARGET/__api__/',
headers={'Host': 'A'*750},
verify=False
)
```
La explotación práctica requeriría **heap grooming** para colocar un objeto controlable justo después del bloque vulnerable, pero la causa raíz destaca dos conclusiones importantes:

1. **_FORTIFY_SOURCE no es una solución mágica** – el mal uso puede anular la protección.
2. Siempre pasa el **tamaño de buffer correcto** a la familia `_chk` (o, aún mejor, usa `snprintf`).

## Referencias
* [watchTowr Labs – Stack Overflows, Heap Overflows and Existential Dread (SonicWall SMA100)](https://labs.watchtowr.com/stack-overflows-heap-overflows-and-existential-dread-sonicwall-sma100-cve-2025-40596-cve-2025-40597-and-cve-2025-40598/)

{{#include ../../banners/hacktricks-training.md}}
