# Techniques de dé-obfuscation manuelle

{{#include ../../banners/hacktricks-training.md}}

## Techniques de **dé-obfuscation manuelle**

Dans le domaine de la **sécurité des logiciels**, le processus de rendre le code obscur compréhensible, connu sous le nom de **dé-obfuscation**, est crucial. Ce guide explore diverses stratégies de dé-obfuscation, en se concentrant sur les techniques d'analyse statique et la reconnaissance des motifs d'obfuscation. De plus, il propose un exercice pour une application pratique et suggère d'autres ressources pour ceux qui souhaitent explorer des sujets plus avancés.

### **Stratégies pour la dé-obfuscation statique**

Lorsqu'il s'agit de **code obfusqué**, plusieurs stratégies peuvent être employées en fonction de la nature de l'obfuscation :

- **Bytecode DEX (Java)** : Une approche efficace consiste à identifier les méthodes de dé-obfuscation de l'application, puis à reproduire ces méthodes dans un fichier Java. Ce fichier est exécuté pour inverser l'obfuscation sur les éléments ciblés.
- **Code Java et natif** : Une autre méthode consiste à traduire l'algorithme de dé-obfuscation dans un langage de script comme Python. Cette stratégie souligne que l'objectif principal n'est pas de comprendre complètement l'algorithme mais de l'exécuter efficacement.

### **Identification de l'obfuscation**

Reconnaître le code obfusqué est la première étape du processus de dé-obfuscation. Les indicateurs clés incluent :

- L'**absence ou le brouillage de chaînes** en Java et Android, ce qui peut suggérer une obfuscation de chaînes.
- La **présence de fichiers binaires** dans le répertoire des ressources ou des appels à `DexClassLoader`, indiquant un déballage de code et un chargement dynamique.
- L'utilisation de **bibliothèques natives accompagnées de fonctions JNI indéfinissables**, indiquant une obfuscation potentielle des méthodes natives.

## **Analyse dynamique dans la dé-obfuscation**

En exécutant le code dans un environnement contrôlé, l'analyse dynamique **permet d'observer comment le code obfusqué se comporte en temps réel**. Cette méthode est particulièrement efficace pour découvrir le fonctionnement interne de motifs d'obfuscation complexes conçus pour cacher la véritable intention du code.

### **Applications de l'analyse dynamique**

- **Décryptage à l'exécution** : De nombreuses techniques d'obfuscation impliquent le chiffrement de chaînes ou de segments de code qui ne sont déchiffrés qu'à l'exécution. Grâce à l'analyse dynamique, ces éléments chiffrés peuvent être capturés au moment du déchiffrement, révélant leur véritable forme.
- **Identification des techniques d'obfuscation** : En surveillant le comportement de l'application, l'analyse dynamique peut aider à identifier des techniques d'obfuscation spécifiques utilisées, telles que la virtualisation de code, les packers ou la génération dynamique de code.
- **Découverte de fonctionnalités cachées** : Le code obfusqué peut contenir des fonctionnalités cachées qui ne sont pas apparentes par une analyse statique seule. L'analyse dynamique permet d'observer tous les chemins de code, y compris ceux exécutés conditionnellement, pour découvrir de telles fonctionnalités cachées.

### Dé-obfuscation automatisée avec LLMs (Androidmeda)

Bien que les sections précédentes se concentrent sur des stratégies entièrement manuelles, en 2025, une nouvelle classe d'outils alimentés par des *modèles de langage de grande taille (LLM)* a émergé, capable d'automatiser la plupart des travaux fastidieux de renommage et de récupération de flux de contrôle. 
Un projet représentatif est **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – un utilitaire Python qui prend des sources Java *décompilées* (par exemple, produites par `jadx`) et renvoie une version considérablement nettoyée, commentée et annotée en matière de sécurité du code.

#### Capacités clés
* Renomme les identifiants sans signification générés par ProGuard / DexGuard / DashO / Allatori / … en noms *sémantiques*.
* Détecte et restructure le **aplatissement du flux de contrôle**, remplaçant les machines d'état switch-case opaques par des boucles normales / des constructions if-else.
* Déchiffre les motifs courants de **chiffrement de chaînes** lorsque cela est possible.
* Injecte des **commentaires en ligne** qui expliquent le but de blocs complexes.
* Effectue un *scan de sécurité statique léger* et écrit les résultats dans `vuln_report.json` avec des niveaux de gravité (informatif → critique).

#### Installation
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Préparation des entrées
1. Décompilez l'APK cible avec `jadx` (ou tout autre décompilateur) et conservez uniquement le répertoire *source* qui contient les fichiers `.java` :
```bash
jadx -d input_dir/ target.apk
```
2. (Optionnel) Réduisez `input_dir/` pour qu'il ne contienne que les packages d'application que vous souhaitez analyser – cela accélère considérablement le traitement et les coûts LLM.

#### Exemples d'utilisation

Fournisseur distant (Gemini-1.5-flash) :
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Hors ligne (backend local `ollama` avec llama3.2) :
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Sortie
* `out/vuln_report.json` – tableau JSON avec `file`, `line`, `issue`, `severity`.
* Un arbre de package miroir avec **fichiers `.java` dé-obfusqués** (uniquement si `--save_code true`).

#### Conseils et dépannage
* **Classe ignorée** ⇒ généralement causée par une méthode non analysable ; isolez le package ou mettez à jour l'expression régulière du parseur.
* **Temps d'exécution lent / utilisation élevée de tokens** ⇒ pointez `--source_dir` vers des packages d'applications *spécifiques* au lieu de l'ensemble de la décompilation.
* Toujours *réviser manuellement* le rapport de vulnérabilité – les hallucinations LLM peuvent conduire à des faux positifs / négatifs.

#### Valeur pratique – Étude de cas sur le malware Crocodilus
L'alimentation d'un échantillon fortement obfusqué du trojan bancaire *Crocodilus* de 2025 à travers Androidmeda a réduit le temps d'analyse de *heures* à *minutes* : l'outil a récupéré la sémantique du graphe d'appels, a révélé des appels aux API d'accessibilité et des URL C2 codées en dur, et a produit un rapport concis pouvant être importé dans les tableaux de bord des analystes.

---

## Références et lectures complémentaires

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018 : “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Cette présentation traite de l'ingénierie inverse de l'une des bibliothèques natives anti-analyse les plus complexes que j'ai vues utilisées par une application Android. Elle couvre principalement les techniques d'obfuscation dans le code natif.
- REcon 2019 : “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Cette présentation discute d'une série de techniques d'obfuscation, uniquement dans le code Java, qu'un botnet Android utilisait pour cacher son comportement.
- Déobfuscation des applications Android avec Androidmeda (article de blog) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Code source d'Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018 : “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Cette présentation traite de l'ingénierie inverse de l'une des bibliothèques natives anti-analyse les plus complexes que j'ai vues utilisées par une application Android. Elle couvre principalement les techniques d'obfuscation dans le code natif.
- REcon 2019 : “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Cette présentation discute d'une série de techniques d'obfuscation, uniquement dans le code Java, qu'un botnet Android utilisait pour cacher son comportement.

{{#include ../../banners/hacktricks-training.md}}
