# Técnicas Manuales de De-obfuscación

{{#include ../../banners/hacktricks-training.md}}

## Técnicas Manuales de **De-obfuscación**

En el ámbito de la **seguridad del software**, el proceso de hacer que el código oscurecido sea comprensible, conocido como **de-obfuscación**, es crucial. Esta guía profundiza en varias estrategias para la de-obfuscación, centrándose en técnicas de análisis estático y el reconocimiento de patrones de ofuscación. Además, introduce un ejercicio para la aplicación práctica y sugiere recursos adicionales para aquellos interesados en explorar temas más avanzados.

### Estrategias para la De-obfuscación Estática

Al tratar con **código ofuscado**, se pueden emplear varias estrategias dependiendo de la naturaleza de la ofuscación:

- **Bytecode DEX (Java)**: Un enfoque efectivo implica identificar los métodos de de-obfuscación de la aplicación, y luego replicar estos métodos en un archivo Java. Este archivo se ejecuta para revertir la ofuscación en los elementos objetivo.
- **Código Java y Nativo**: Otro método es traducir el algoritmo de de-obfuscación a un lenguaje de scripting como Python. Esta estrategia destaca que el objetivo principal no es entender completamente el algoritmo, sino ejecutarlo de manera efectiva.

### Identificación de la Ofuscación

Reconocer el código ofuscado es el primer paso en el proceso de de-obfuscación. Los indicadores clave incluyen:

- La **ausencia o desorden de cadenas** en Java y Android, lo que puede sugerir ofuscación de cadenas.
- La **presencia de archivos binarios** en el directorio de assets o llamadas a `DexClassLoader`, lo que sugiere desempaquetado de código y carga dinámica.
- El uso de **bibliotecas nativas junto con funciones JNI no identificables**, indicando una posible ofuscación de métodos nativos.

## Análisis Dinámico en la De-obfuscación

Al ejecutar el código en un entorno controlado, el análisis dinámico **permite observar cómo se comporta el código ofuscado en tiempo real**. Este método es particularmente efectivo para descubrir el funcionamiento interno de patrones de ofuscación complejos que están diseñados para ocultar la verdadera intención del código.

### Aplicaciones del Análisis Dinámico

- **Desencriptación en Tiempo de Ejecución**: Muchas técnicas de ofuscación implican cifrar cadenas o segmentos de código que solo se desencriptan en tiempo de ejecución. A través del análisis dinámico, estos elementos cifrados pueden ser capturados en el momento de la desencriptación, revelando su forma verdadera.
- **Identificación de Técnicas de Ofuscación**: Al monitorear el comportamiento de la aplicación, el análisis dinámico puede ayudar a identificar técnicas específicas de ofuscación que se están utilizando, como virtualización de código, empaquetadores o generación dinámica de código.
- **Descubrimiento de Funcionalidades Ocultas**: El código ofuscado puede contener funcionalidades ocultas que no son evidentes a través del análisis estático solo. El análisis dinámico permite observar todos los caminos de código, incluidos aquellos ejecutados condicionalmente, para descubrir tales funcionalidades ocultas.

### De-obfuscación Automatizada con LLMs (Androidmeda)

Mientras que las secciones anteriores se centran en estrategias completamente manuales, en 2025 surgió una nueva clase de herramientas impulsadas por *Modelos de Lenguaje Grande (LLM)* que pueden automatizar la mayor parte del tedioso trabajo de renombrado y recuperación de flujo de control. 
Un proyecto representativo es **[Androidmeda](https://github.com/In3tinct/Androidmeda)** – una utilidad de Python que toma fuentes Java *decompiladas* (por ejemplo, producidas por `jadx`) y devuelve una versión del código significativamente limpiada, comentada y anotada en seguridad.

#### Capacidades clave
* Renombra identificadores sin sentido generados por ProGuard / DexGuard / DashO / Allatori / … a nombres *semánticos*.
* Detecta y reestructura **aplanamiento de flujo de control**, reemplazando máquinas de estado opacas de switch-case con bucles normales / construcciones if-else.
* Desencripta patrones comunes de **cifrado de cadenas** cuando es posible.
* Inyecta **comentarios en línea** que explican el propósito de bloques complejos.
* Realiza un *escaneo de seguridad estático ligero* y escribe los hallazgos en `vuln_report.json` con niveles de severidad (informativo → crítico).

#### Instalación
```bash
git clone https://github.com/In3tinct/Androidmeda
cd Androidmeda
pip3 install -r requirements.txt
```
#### Preparando las entradas
1. Descompón el APK objetivo con `jadx` (o cualquier otro descompilador) y conserva solo el directorio *source* que contiene los archivos `.java`:
```bash
jadx -d input_dir/ target.apk
```
2. (Opcional) Recorta `input_dir/` para que solo contenga los paquetes de la aplicación que deseas analizar; esto acelera enormemente el procesamiento y los costos de LLM.

#### Ejemplos de uso

Proveedor remoto (Gemini-1.5-flash):
```bash
export OPENAI_API_KEY=<your_key>
python3 androidmeda.py \
--llm_provider google \
--llm_model gemini-1.5-flash \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
Sin conexión (backend local `ollama` con llama3.2):
```bash
python3 androidmeda.py \
--llm_provider ollama \
--llm_model llama3.2 \
--source_dir input_dir/ \
--output_dir out/ \
--save_code true
```
#### Salida
* `out/vuln_report.json` – Array JSON con `file`, `line`, `issue`, `severity`.
* Un árbol de paquetes reflejado con **archivos `.java` de-deofuscados** (solo si `--save_code true`).

#### Consejos y solución de problemas
* **Clase omitida** ⇒ generalmente causada por un método no analizable; aísle el paquete o actualice la expresión regular del analizador.
* **Tiempo de ejecución lento / alto uso de tokens** ⇒ apunte `--source_dir` a *paquetes* de aplicaciones *específicos* en lugar de a toda la decompilación.
* Siempre *revise manualmente* el informe de vulnerabilidades – las alucinaciones de LLM pueden llevar a falsos positivos / negativos.

#### Valor práctico – Estudio de caso del malware Crocodilus
Alimentar una muestra fuertemente ofuscada del troyano bancario *Crocodilus* de 2025 a través de Androidmeda redujo el tiempo de análisis de *horas* a *minutos*: la herramienta recuperó la semántica del gráfico de llamadas, reveló llamadas a APIs de accesibilidad y URLs C2 codificadas, y produjo un informe conciso que podría ser importado a los paneles de los analistas.

---

## Referencias y Lectura Adicional

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” [[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta charla trata sobre la ingeniería inversa de una de las bibliotecas nativas anti-análisis más complejas que he visto utilizadas por una aplicación de Android. Cubre principalmente técnicas de ofuscación en código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” [[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta charla discute una serie de técnicas de ofuscación, únicamente en código Java, que una botnet de Android estaba utilizando para ocultar su comportamiento.
- Deobfuscating Android Apps with Androidmeda (publicación de blog) – [mobile-hacker.com](https://www.mobile-hacker.com/2025/07/22/deobfuscating-android-apps-with-androidmeda-a-smarter-way-to-read-obfuscated-code/)
- Código fuente de Androidmeda – [https://github.com/In3tinct/Androidmeda](https://github.com/In3tinct/Androidmeda)

- [https://maddiestone.github.io/AndroidAppRE/obfuscation.html](https://maddiestone.github.io/AndroidAppRE/obfuscation.html)
- BlackHat USA 2018: “Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Library” \[[video](https://www.youtube.com/watch?v=s0Tqi7fuOSU)]
- Esta charla trata sobre la ingeniería inversa de una de las bibliotecas nativas anti-análisis más complejas que he visto utilizadas por una aplicación de Android. Cubre principalmente técnicas de ofuscación en código nativo.
- REcon 2019: “The Path to the Payload: Android Edition” \[[video](https://recon.cx/media-archive/2019/Session.005.Maddie_Stone.The_path_to_the_payload_Android_Edition-J3ZnNl2GYjEfa.mp4)]
- Esta charla discute una serie de técnicas de ofuscación, únicamente en código Java, que una botnet de Android estaba utilizando para ocultar su comportamiento.

{{#include ../../banners/hacktricks-training.md}}
