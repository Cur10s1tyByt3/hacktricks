# Bypass Biometric Authentication (Android)

{{#include ../../banners/hacktricks-training.md}}

## **Méthode 1 – Contournement sans utilisation d'objet Crypto**

L'accent est mis ici sur le _onAuthenticationSucceeded_ callback, qui est crucial dans le processus d'authentification. Des chercheurs de WithSecure ont développé un [script Frida](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass.js), permettant de contourner le NULL _CryptoObject_ dans _onAuthenticationSucceeded(...)_. Le script force un contournement automatique de l'authentification par empreinte digitale lors de l'invocation de la méthode. Ci-dessous se trouve un extrait simplifié démontrant le contournement dans un contexte d'empreinte digitale Android, avec l'application complète disponible sur [GitHub](https://github.com/St3v3nsS/InsecureBanking).
```javascript
biometricPrompt = new BiometricPrompt(this, executor, new BiometricPrompt.AuthenticationCallback() {
@Override
public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {
Toast.makeText(MainActivity.this,"Success",Toast.LENGTH_LONG).show();
}
});
```
Commande pour exécuter le script Frida :
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass.js
```
## **Méthode 2 – Approche de gestion des exceptions**

Un autre [script Frida](https://github.com/WithSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass-via-exception-handling.js) de WithSecure traite du contournement de l'utilisation d'objets cryptographiques non sécurisés. Le script invoque _onAuthenticationSucceeded_ avec un _CryptoObject_ qui n'a pas été autorisé par une empreinte digitale. Si l'application essaie d'utiliser un objet de chiffrement différent, cela déclenchera une exception. Le script se prépare à invoquer _onAuthenticationSucceeded_ et à gérer le _javax.crypto.IllegalBlockSizeException_ dans la classe _Cipher_, garantissant que les objets suivants utilisés par l'application sont chiffrés avec la nouvelle clé.

Commande pour exécuter le script Frida :
```bash
frida -U -f com.generic.insecurebankingfingerprint --no-pause -l fingerprint-bypass-via-exception-handling.js
```
Lors de l'accès à l'écran d'empreinte digitale et de l'initiation de `authenticate()`, tapez `bypass()` dans la console Frida pour activer le contournement :
```
Spawning com.generic.insecurebankingfingerprint...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> Hooking BiometricPrompt.authenticate()...
Hooking BiometricPrompt.authenticate2()...
Hooking FingerprintManager.authenticate()...
[Android Emulator 5554::com.generic.insecurebankingfingerprint]-> bypass()
```
## **Méthode 3 – Cadres d'instrumentation**

Les cadres d'instrumentation comme Xposed ou Frida peuvent être utilisés pour s'accrocher aux méthodes d'application à l'exécution. Pour l'authentification par empreinte digitale, ces cadres peuvent :

1. **Simuler les rappels d'authentification** : En s'accrochant aux méthodes `onAuthenticationSucceeded`, `onAuthenticationFailed` ou `onAuthenticationError` de `BiometricPrompt.AuthenticationCallback`, vous pouvez contrôler le résultat du processus d'authentification par empreinte digitale.
2. **Contourner le SSL Pinning** : Cela permet à un attaquant d'intercepter et de modifier le trafic entre le client et le serveur, potentiellement en altérant le processus d'authentification ou en volant des données sensibles.

Exemple de commande pour Frida :
```bash
frida -U -l script-to-bypass-authentication.js --no-pause -f com.generic.in
```
## **Méthode 4 – Ingénierie Inverse & Modification de Code**

Les outils d'ingénierie inverse comme `APKTool`, `dex2jar` et `JD-GUI` peuvent être utilisés pour décompiler une application Android, lire son code source et comprendre son mécanisme d'authentification. Les étapes incluent généralement :

1. **Décompilation de l'APK** : Convertir le fichier APK en un format plus lisible par l'homme (comme le code Java).
2. **Analyse du Code** : Rechercher l'implémentation de l'authentification par empreinte digitale et identifier les faiblesses potentielles (comme les mécanismes de secours ou les vérifications de validation incorrectes).
3. **Recompilation de l'APK** : Après avoir modifié le code pour contourner l'authentification par empreinte digitale, l'application est recompilée, signée et installée sur l'appareil pour des tests.

## **Méthode 5 – Utilisation d'Outils d'Authentification Personnalisés**

Il existe des outils et des scripts spécialisés conçus pour tester et contourner les mécanismes d'authentification. Par exemple :

1. **Modules MAGISK** : MAGISK est un outil pour Android qui permet aux utilisateurs de rooter leurs appareils et d'ajouter des modules qui peuvent modifier ou usurper des informations au niveau matériel, y compris les empreintes digitales.
2. **Scripts Personnalisés** : Des scripts peuvent être écrits pour interagir avec l'Android Debug Bridge (ADB) ou directement avec le backend de l'application pour simuler ou contourner l'authentification par empreinte digitale.

---

## **Méthode 6 – Hook Frida Universel pour `BiometricPrompt` (API 28-34)**

En 2023, un script Frida communautaire nommé **Universal-Android-Biometric-Bypass** est apparu sur CodeShare. Le script intercepte chaque surcharge de `BiometricPrompt.authenticate()` ainsi que l'héritage `FingerprintManager.authenticate()` et déclenche directement `onAuthenticationSucceeded()` avec un **`AuthenticationResult` fabriqué contenant un `CryptoObject` nul**. Comme il s'adapte dynamiquement aux niveaux d'API, il fonctionne toujours sur Android 14 (API 34) si l'application cible ne réalise **aucune vérification cryptographique sur le `CryptoObject` retourné**.
```bash
# Install the script from CodeShare and run it against the target package
frida -U -f com.target.app --no-pause -l universal-android-biometric-bypass.js
```
Idées clés
* Tout se passe dans l'espace utilisateur – aucune exploitation du noyau ou accès root n'est requis.
* L'attaque reste complètement silencieuse pour l'interface utilisateur : le dialogue biométrique du système n'apparaît jamais.
* Atténuation : **vérifiez toujours `result.cryptoObject` et son chiffre/signature avant de déverrouiller des fonctionnalités sensibles**.

## **Méthode 7 – Manipulation de rétrogradation / de secours**

À partir d'Android 11, les développeurs peuvent spécifier quels authentificateurs sont acceptables via `setAllowedAuthenticators()` (ou l'ancienne `setDeviceCredentialAllowed()`). Une attaque de **runtime hooking** peut forcer le champ de bits `allowedAuthenticators` à la valeur plus faible `BIOMETRIC_WEAK | DEVICE_CREDENTIAL` :
```javascript
// Frida one-liner – replace strong-only policy with weak/device-credential
var PromptInfoBuilder = Java.use('androidx.biometric.BiometricPrompt$PromptInfo$Builder');
PromptInfoBuilder.setAllowedAuthenticators.implementation = function(flags){
return this.setAllowedAuthenticators(0x0002 | 0x8000); // BIOMETRIC_WEAK | DEVICE_CREDENTIAL
};
```
Si l'application **ne** valide pas par la suite le `AuthenticationResult` retourné, un attaquant peut simplement appuyer sur le bouton de secours _PIN/Pattern_ ou même enregistrer une nouvelle biométrie faible pour accéder.

## **Méthode 8 – CVEs au niveau du fournisseur / noyau**

Restez attentif aux bulletins de sécurité Android : plusieurs bugs récents côté noyau permettent une élévation de privilèges locale via le HAL d'empreinte digitale et désactivent ou court-circuitent effectivement **le pipeline du capteur**. Les exemples incluent :

* **CVE-2023-20995** – erreur logique dans `captureImage` de `CustomizedSensor.cpp` (Pixel 8, Android 13) permettant de contourner le déverrouillage sans interaction de l'utilisateur.
* **CVE-2024-53835 / CVE-2024-53840** – “contournement biométrique possible en raison d'une cause racine inhabituelle” corrigé dans le **bulletin Pixel de décembre 2024**.

Bien que ces vulnérabilités ciblent l'écran de verrouillage, un testeur rooté peut les enchaîner avec des défauts au niveau de l'application pour contourner les biométries dans l'application également.

---

### Liste de vérification de durcissement pour les développeurs (Notes rapides pour pentesters)

* Appliquez `setUserAuthenticationRequired(true)` et `setInvalidatedByBiometricEnrollment(true)` lors de la génération des clés **Keystore**. Une biométrie valide est alors requise avant que la clé puisse être utilisée.
* Rejetez un `CryptoObject` avec **null ou un chiffre / signature inattendu** ; considérez cela comme une erreur d'authentification fatale.
* Lors de l'utilisation de `BiometricPrompt`, préférez `BIOMETRIC_STRONG` et **ne revenez jamais à `BIOMETRIC_WEAK` ou `DEVICE_CREDENTIAL`** pour des actions à haut risque.
* Fixez la dernière version `androidx.biometric` (≥1.2.0-beta02) – les versions récentes ajoutent des vérifications automatiques de chiffre nul et resserrent les combinaisons d'authentificateurs autorisées.

## Références

- [Universal Android Biometric Bypass – Frida CodeShare](https://codeshare.frida.re/@ax/universal-android-biometric-bypass/)
- [Android Pixel Security Bulletin 2024-12-01](https://source.android.com/security/bulletin/pixel/2024-12-01)


{{#include ../../banners/hacktricks-training.md}}
