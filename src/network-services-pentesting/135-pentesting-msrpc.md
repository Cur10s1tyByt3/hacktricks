# 135, 593 - Pentesting MSRPC

{{#include ../banners/hacktricks-training.md}}

## Información Básica

El protocolo Microsoft Remote Procedure Call (MSRPC), un modelo cliente-servidor que permite a un programa solicitar un servicio de un programa ubicado en otra computadora sin entender los detalles de la red, se derivó inicialmente de software de código abierto y luego fue desarrollado y protegido por Microsoft.

El mapeador de puntos finales RPC se puede acceder a través del puerto TCP y UDP 135, SMB en TCP 139 y 445 (con una sesión nula o autenticada), y como un servicio web en el puerto TCP 593.
```
135/tcp   open     msrpc         Microsoft Windows RPC
```
## ¿Cómo funciona MSRPC?

Iniciado por la aplicación cliente, el proceso MSRPC implica llamar a un procedimiento stub local que luego interactúa con la biblioteca de tiempo de ejecución del cliente para preparar y transmitir la solicitud al servidor. Esto incluye convertir parámetros en un formato estándar de Representación de Datos de Red. La elección del protocolo de transporte es determinada por la biblioteca de tiempo de ejecución si el servidor es remoto, asegurando que el RPC se entregue a través de la pila de red.

![https://0xffsec.com/handbook/images/msrpc.png](https://0xffsec.com/handbook/images/msrpc.png)

## **Identificación de Servicios RPC Expuestos**

La exposición de servicios RPC a través de TCP, UDP, HTTP y SMB puede determinarse consultando el servicio localizador de RPC y los puntos finales individuales. Herramientas como rpcdump facilitan la identificación de servicios RPC únicos, denotados por valores **IFID**, revelando detalles del servicio y enlaces de comunicación:
```
D:\rpctools> rpcdump [-p port] <IP>
**IFID**: 5a7b91f8-ff00-11d0-a9b2-00c04fb6e6fc version 1.0
Annotation: Messenger Service
UUID: 00000000-0000-0000-0000-000000000000
Binding: ncadg_ip_udp:<IP>[1028]
```
El acceso al servicio de localización RPC está habilitado a través de protocolos específicos: ncacn_ip_tcp y ncadg_ip_udp para acceder a través del puerto 135, ncacn_np para conexiones SMB y ncacn_http para comunicación RPC basada en web. Los siguientes comandos ejemplifican la utilización de módulos de Metasploit para auditar e interactuar con servicios MSRPC, centrándose principalmente en el puerto 135:
```bash
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
rpcdump.py <IP> -p 135
```
Todas las opciones excepto `tcp_dcerpc_auditor` están diseñadas específicamente para apuntar a MSRPC en el puerto 135.

#### Interfaces RPC notables

- **IFID**: 12345778-1234-abcd-ef00-0123456789ab
- **Named Pipe**: `\pipe\lsarpc`
- **Descripción**: Interfaz LSA, utilizada para enumerar usuarios.
- **IFID**: 3919286a-b10c-11d0-9ba8-00c04fd92ef5
- **Named Pipe**: `\pipe\lsarpc`
- **Descripción**: Interfaz de Servicios de Directorio LSA (DS), utilizada para enumerar dominios y relaciones de confianza.
- **IFID**: 12345778-1234-abcd-ef00-0123456789ac
- **Named Pipe**: `\pipe\samr`
- **Descripción**: Interfaz LSA SAMR, utilizada para acceder a elementos de la base de datos SAM pública (por ejemplo, nombres de usuario) y realizar ataques de fuerza bruta a contraseñas de usuarios sin importar la política de bloqueo de cuentas.
- **IFID**: 1ff70682-0a51-30e8-076d-740be8cee98b
- **Named Pipe**: `\pipe\atsvc`
- **Descripción**: Programador de tareas, utilizado para ejecutar comandos de forma remota.
- **IFID**: 338cd001-2244-31f1-aaaa-900038001003
- **Named Pipe**: `\pipe\winreg`
- **Descripción**: Servicio de registro remoto, utilizado para acceder y modificar el registro del sistema.
- **IFID**: 367abb81-9844-35f1-ad32-98f038001003
- **Named Pipe**: `\pipe\svcctl`
- **Descripción**: Administrador de control de servicios y servicios de servidor, utilizado para iniciar y detener servicios de forma remota y ejecutar comandos.
- **IFID**: 4b324fc8-1670-01d3-1278-5a47bf6ee188
- **Named Pipe**: `\pipe\srvsvc`
- **Descripción**: Administrador de control de servicios y servicios de servidor, utilizado para iniciar y detener servicios de forma remota y ejecutar comandos.
- **IFID**: 4d9f4ab8-7d1c-11cf-861e-0020af6e7c57
- **Named Pipe**: `\pipe\epmapper`
- **Descripción**: Interfaz DCOM, utilizada para ataques de fuerza bruta a contraseñas y recopilación de información a través de WM.

### Identificación de direcciones IP

Usando [https://github.com/mubix/IOXIDResolver](https://github.com/mubix/IOXIDResolver), proveniente de [Airbus research](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/), es posible abusar del método _**ServerAlive2**_ dentro de la interfaz _**IOXIDResolver**_.

Este método se ha utilizado para obtener información de la interfaz como la dirección **IPv6** de la caja HTB _APT_. Vea [aquí](https://0xdf.gitlab.io/2021/04/10/htb-apt.html) para el informe de 0xdf APT, que incluye un método alternativo usando rpcmap.py de [Impacket](https://github.com/SecureAuthCorp/impacket/) con _stringbinding_ (ver arriba).

### Ejecución de un RCE con credenciales válidas

Es posible ejecutar código remoto en una máquina, si las credenciales de un usuario válido están disponibles utilizando [dcomexec.py](https://github.com/fortra/impacket/blob/master/examples/dcomexec.py) del marco impacket.

**Recuerde intentar con los diferentes objetos disponibles**

- ShellWindows
- ShellBrowserWindow
- MMC20

## Puerto 593

El **rpcdump.exe** de [rpctools](https://resources.oreilly.com/examples/9780596510305/tree/master/tools/rpctools) puede interactuar con este puerto.

## Fuzzing automatizado de interfaces MSRPC

Las interfaces MS-RPC exponen una gran superficie de ataque, a menudo no documentada. El módulo de PowerShell de código abierto [MS-RPC-Fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer) se basa en `NtObjectManager` de James Forshaw para *crear dinámicamente* stubs de cliente RPC a partir de los metadatos de la interfaz que ya están presentes en los binarios de Windows. Una vez que existe un stub, el módulo puede bombardear cada procedimiento con entradas mutadas y registrar el resultado, haciendo **posible el fuzzing reproducible y a gran escala de los puntos finales RPC sin escribir una sola línea de IDL**.

### 1. Inventario de las interfaces
```powershell
# Import the module (download / git clone first)
Import-Module .\MS-RPC-Fuzzer.psm1

# Parse a single binary
Get-RpcServerData -Target "C:\Windows\System32\efssvc.dll" -OutPath .\output

# Or crawl the whole %SystemRoot%\System32 directory
Get-RpcServerData -OutPath .\output
```
`Get-RpcServerData` extraerá el UUID, la versión, las cadenas de enlace (named-pipe / TCP / HTTP) y **los prototipos de procedimiento completos** para cada interfaz que encuentre y los almacenará en `rpcServerData.json`.

### 2. Ejecutar el fuzzer
```powershell
'.\output\rpcServerData.json' |
Invoke-RpcFuzzer -OutPath .\output `
-MinStrLen 100  -MaxStrLen 1000 `
-MinIntSize 9999 -MaxIntSize 99999
```
Opciones relevantes:

* `-MinStrLen` / `-MaxStrLen` – rango de tamaño para cadenas generadas
* `-MinIntSize` / `-MaxIntSize` – rango de valores para enteros mutados (útil para pruebas de desbordamiento)
* `-Sorted` – ejecutar procedimientos en un orden que respete **dependencias de parámetros** para que las salidas de una llamada puedan servir como entradas de la siguiente (aumenta drásticamente los caminos alcanzables)

El fuzzer implementa 2 estrategias:

1. **Fuzzer por defecto** – valores primitivos aleatorios + instancias predeterminadas para tipos complejos
2. **Fuzzer ordenado**  – ordenamiento consciente de dependencias (ver `docs/Procedure dependency design.md`)

Cada llamada se escribe de manera atómica en `log.txt`; después de un fallo, la **última línea te dice inmediatamente el procedimiento ofensivo**. El resultado de cada llamada también se categoriza en tres archivos JSON:

* `allowed.json` – la llamada tuvo éxito y devolvió datos
* `denied.json`  – el servidor respondió con *Acceso Denegado*
* `error.json`   – cualquier otro error / fallo

### 3. Visualizar con Neo4j
```powershell
'.\output\allowed.json' |
Import-DataToNeo4j -Neo4jHost 192.168.56.10:7474 -Neo4jUsername neo4j
```
`Import-DataToNeo4j` convierte los artefactos JSON en una estructura de grafo donde:

* Los servidores RPC, interfaces y procedimientos son **nodos**
* Las interacciones (`ALLOWED`, `DENIED`, `ERROR`) son **relaciones**

Las consultas Cypher se pueden usar para detectar rápidamente procedimientos peligrosos o para reproducir la cadena exacta de llamadas que precedieron a un fallo.

⚠️  El fuzzer es *destructivo*: espera caídas del servicio e incluso BSODs – siempre ejecútalo en un snapshot de VM aislado.


### Enumeración de Interfaces Automatizada y Generación Dinámica de Clientes (NtObjectManager)

El gurú de PowerShell **James Forshaw** expuso la mayor parte de los internals de Windows RPC dentro del módulo de código abierto *NtObjectManager*. Usándolo, puedes convertir cualquier DLL / EXE de servidor RPC en un **stub de cliente completamente funcional** en segundos – sin necesidad de IDL, MIDL o unmarshalling manual.
```powershell
# Install the module once
Install-Module NtObjectManager -Force

# Parse every RPC interface exported by the target binary
$rpcinterfaces = Get-RpcServer "C:\Windows\System32\efssvc.dll"
$rpcinterfaces | Format-Table Name,Uuid,Version,Procedures

# Inspect a single procedure (opnum 0)
$rpcinterfaces[0].Procedures[0] | Format-List *
```
La salida típica expone los tipos de parámetros exactamente como aparecen en **MIDL** (por ejemplo, `FC_C_WSTRING`, `FC_LONG`, `FC_BIND_CONTEXT`).

Una vez que conozcas la interfaz, puedes **generar un cliente C# listo para compilar**:
```powershell
# Reverse the MS-EFSR (EfsRpc*) interface into C#
Format-RpcClient $rpcinterfaces[0] -Namespace MS_EFSR -OutputPath .\MS_EFSR.cs
```
Dentro del stub producido, encontrarás métodos como:
```csharp
public int EfsRpcOpenFileRaw(out Marshal.NdrContextHandle ctx, string FileName, int Flags) {
// marshals parameters & calls opnum 0
}
```
El ayudante de PowerShell `Get-RpcClient` puede crear un **objeto cliente interactivo** para que puedas llamar al procedimiento de inmediato:
```powershell
$client = Get-RpcClient $rpcinterfaces[0]
Connect-RpcClient $client -stringbinding 'ncacn_np:127.0.0.1[\\pipe\\efsrpc]' `
-AuthenticationLevel PacketPrivacy `
-AuthenticationType  WinNT  # NTLM auth

# Invoke the procedure → returns an authenticated context handle
$ctx = New-Object Marshal.NdrContextHandle
$client.EfsRpcOpenFileRaw([ref]$ctx, "\\\127.0.0.1\test", 0)
```
Autenticación (Kerberos / NTLM) y niveles de cifrado (`PacketIntegrity`, `PacketPrivacy`, …) se pueden proporcionar directamente a través del cmdlet `Connect-RpcClient` – ideal para **eludir Descriptores de Seguridad** que protegen tuberías con privilegios elevados.

### Fuzzing RPC Consciente del Contexto (MS-RPC-Fuzzer)

El conocimiento estático de la interfaz es excelente, pero lo que realmente deseas es **fuzzing guiado por cobertura** que entienda *manejadores de contexto* y cadenas de parámetros complejas. El proyecto de código abierto **MS-RPC-Fuzzer** automatiza exactamente ese flujo de trabajo:

1. Enumerar cada interfaz/procedimiento exportado por el binario objetivo (`Get-RpcServer`).
2. Generar clientes dinámicos para cada interfaz (`Format-RpcClient`).
3. Aleatorizar parámetros de entrada (longitud de cadenas amplias, rangos de enteros, enums) mientras se respeta el **tipo NDR** original.
4. Rastrear *manejadores de contexto* devueltos por una llamada para alimentar automáticamente procedimientos de seguimiento.
5. Realizar llamadas de alto volumen contra el transporte elegido (ALPC, TCP, HTTP o tubería nombrada).
6. Registrar estados de salida / fallos / tiempos de espera y exportar un archivo de importación de **Neo4j** para visualizar relaciones de *interfaz → procedimiento → parámetro* y clusters de fallos.

Ejemplo de ejecución (objetivo de tubería nombrada):
```powershell
Invoke-MSRPCFuzzer -Pipe "\\.\pipe\efsrpc" -Auth NTLM `
-MinLen 1  -MaxLen 0x400 `
-Iterations 100000 `
-OutDir .\results
```
Una única escritura fuera de límites o una excepción inesperada se mostrará inmediatamente con el opnum exacto + la carga útil fuzzed que la activó, lo que representa un punto de partida perfecto para un exploit de prueba de concepto estable.

> ⚠️  Muchos servicios RPC se ejecutan en procesos que funcionan como **NT AUTHORITY\SYSTEM**. Cualquier problema de seguridad de memoria aquí generalmente se traduce en escalada de privilegios local o (cuando se expone a través de SMB/135) *ejecución remota de código*.


## Referencias

- [Automating MS-RPC vulnerability research (2025, Incendium.rocks)](https://www.incendium.rocks/posts/Automating-MS-RPC-Vulnerability-Research/)
- [MS-RPC-Fuzzer – context-aware RPC fuzzer](https://github.com/warpnet/MS-RPC-Fuzzer)
- [NtObjectManager PowerShell module](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/master/NtObjectManager)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/](https://www.cyber.airbus.com/the-oxid-resolver-part-1-remote-enumeration-of-network-interfaces-without-any-authentication/)
- [https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/](https://www.cyber.airbus.com/the-oxid-resolver-part-2-accessing-a-remote-object-inside-dcom/)
- [https://0xffsec.com/handbook/services/msrpc/](https://0xffsec.com/handbook/services/msrpc/)
- [MS-RPC-Fuzzer (GitHub)](https://github.com/warpnet/MS-RPC-Fuzzer)

{{#include ../banners/hacktricks-training.md}}
