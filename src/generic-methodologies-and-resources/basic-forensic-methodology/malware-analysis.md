# Análisis de Malware

{{#include ../../banners/hacktricks-training.md}}

## Hojas de Trucos de Forense

[https://www.jaiminton.com/cheatsheet/DFIR/#](https://www.jaiminton.com/cheatsheet/DFIR/)

## Servicios en Línea

- [VirusTotal](https://www.virustotal.com/gui/home/upload)
- [HybridAnalysis](https://www.hybrid-analysis.com)
- [Koodous](https://koodous.com)
- [Intezer](https://analyze.intezer.com)
- [Any.Run](https://any.run/)

## Herramientas de Antivirus y Detección Offline

### Yara

#### Instalar
```bash
sudo apt-get install -y yara
```
#### Preparar reglas

Use este script para descargar y fusionar todas las reglas de malware yara de github: [https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9](https://gist.github.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9)\
Cree el directorio _**rules**_ y ejecútelo. Esto creará un archivo llamado _**malware_rules.yar**_ que contiene todas las reglas yara para malware.
```bash
wget https://gist.githubusercontent.com/andreafortuna/29c6ea48adf3d45a979a78763cdc7ce9/raw/4ec711d37f1b428b63bed1f786b26a0654aa2f31/malware_yara_rules.py
mkdir rules
python malware_yara_rules.py
```
#### Escanear
```bash
yara -w malware_rules.yar image  #Scan 1 file
yara -w malware_rules.yar folder #Scan the whole folder
```
#### YaraGen: Verificar malware y crear reglas

Puedes usar la herramienta [**YaraGen**](https://github.com/Neo23x0/yarGen) para generar reglas yara a partir de un binario. Consulta estos tutoriales: [**Parte 1**](https://www.nextron-systems.com/2015/02/16/write-simple-sound-yara-rules/), [**Parte 2**](https://www.nextron-systems.com/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/), [**Parte 3**](https://www.nextron-systems.com/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/)
```bash
python3 yarGen.py --update
python3.exe yarGen.py --excludegood -m  ../../mals/
```
### ClamAV

#### Instalar
```
sudo apt-get install -y clamav
```
#### Escanear
```bash
sudo freshclam      #Update rules
clamscan filepath   #Scan 1 file
clamscan folderpath #Scan the whole folder
```
### [Capa](https://github.com/mandiant/capa)

**Capa** detecta capacidades **potencialmente maliciosas** en ejecutables: PE, ELF, .NET. Así que encontrará cosas como tácticas de Att\&ck, o capacidades sospechosas como:

- verificar el error de OutputDebugString
- ejecutarse como un servicio
- crear proceso

Consíguelo en el [**repositorio de Github**](https://github.com/mandiant/capa).

### IOCs

IOC significa Indicador de Compromiso. Un IOC es un conjunto de **condiciones que identifican** algún software potencialmente no deseado o **malware** confirmado. Los Blue Teams utilizan este tipo de definición para **buscar este tipo de archivos maliciosos** en sus **sistemas** y **redes**.\
Compartir estas definiciones es muy útil, ya que cuando se identifica malware en una computadora y se crea un IOC para ese malware, otros Blue Teams pueden usarlo para identificar el malware más rápido.

Una herramienta para crear o modificar IOCs es [**IOC Editor**](https://www.fireeye.com/services/freeware/ioc-editor.html)**.**\
Puedes usar herramientas como [**Redline**](https://www.fireeye.com/services/freeware/redline.html) para **buscar IOCs definidos en un dispositivo**.

### Loki

[**Loki**](https://github.com/Neo23x0/Loki) es un escáner para Indicadores Simples de Compromiso.\
La detección se basa en cuatro métodos de detección:
```
1. File Name IOC
Regex match on full file path/name

2. Yara Rule Check
Yara signature matches on file data and process memory

3. Hash Check
Compares known malicious hashes (MD5, SHA1, SHA256) with scanned files

4. C2 Back Connect Check
Compares process connection endpoints with C2 IOCs (new since version v.10)
```
### Linux Malware Detect

[**Linux Malware Detect (LMD)**](https://www.rfxn.com/projects/linux-malware-detect/) es un escáner de malware para Linux lanzado bajo la licencia GNU GPLv2, que está diseñado en torno a las amenazas que se enfrentan en entornos de alojamiento compartido. Utiliza datos de amenazas de sistemas de detección de intrusiones en el borde de la red para extraer malware que se está utilizando activamente en ataques y genera firmas para la detección. Además, los datos de amenazas también se derivan de las presentaciones de los usuarios con la función de verificación de LMD y recursos de la comunidad de malware.

### rkhunter

Herramientas como [**rkhunter**](http://rkhunter.sourceforge.net) se pueden utilizar para verificar el sistema de archivos en busca de posibles **rootkits** y malware.
```bash
sudo ./rkhunter --check -r / -l /tmp/rkhunter.log [--report-warnings-only] [--skip-keypress]
```
### FLOSS

[**FLOSS**](https://github.com/mandiant/flare-floss) es una herramienta que intentará encontrar cadenas ofuscadas dentro de ejecutables utilizando diferentes técnicas.

### PEpper

[PEpper ](https://github.com/Th3Hurrican3/PEpper)verifica algunas cosas básicas dentro del ejecutable (datos binarios, entropía, URLs e IPs, algunas reglas yara).

### PEstudio

[PEstudio](https://www.winitor.com/download) es una herramienta que permite obtener información de ejecutables de Windows como importaciones, exportaciones, encabezados, pero también verificará virus total y encontrará técnicas potenciales de Att\&ck.

### Detect It Easy(DiE)

[**DiE**](https://github.com/horsicq/Detect-It-Easy/) es una herramienta para detectar si un archivo está **encriptado** y también encontrar **empaquetadores**.

### NeoPI

[**NeoPI** ](https://github.com/CiscoCXSecurity/NeoPI)es un script de Python que utiliza una variedad de **métodos estadísticos** para detectar contenido **ofuscado** y **encriptado** dentro de archivos de texto/script. El propósito de NeoPI es ayudar en la **detección de código de shell web oculto**.

### **php-malware-finder**

[**PHP-malware-finder**](https://github.com/nbs-system/php-malware-finder) hace su mejor esfuerzo para detectar **código ofuscado**/**sospechoso** así como archivos que utilizan funciones de **PHP** a menudo usadas en **malwares**/webshells.

### Apple Binary Signatures

Al revisar alguna **muestra de malware** siempre debes **verificar la firma** del binario ya que el **desarrollador** que la firmó puede estar ya **relacionado** con **malware.**
```bash
#Get signer
codesign -vv -d /bin/ls 2>&1 | grep -E "Authority|TeamIdentifier"

#Check if the app’s contents have been modified
codesign --verify --verbose /Applications/Safari.app

#Check if the signature is valid
spctl --assess --verbose /Applications/Safari.app
```
## Técnicas de Detección

### Apilamiento de Archivos

Si sabes que alguna carpeta que contiene los **archivos** de un servidor web fue **actualizada por última vez en alguna fecha**. **Verifica** la **fecha** en que todos los **archivos** en el **servidor web fueron creados y modificados** y si alguna fecha es **sospechosa**, revisa ese archivo.

### Líneas Base

Si los archivos de una carpeta **no deberían haber sido modificados**, puedes calcular el **hash** de los **archivos originales** de la carpeta y **compararlos** con los **actuales**. Cualquier cosa modificada será **sospechosa**.

### Análisis Estadístico

Cuando la información se guarda en registros, puedes **verificar estadísticas como cuántas veces se accedió a cada archivo de un servidor web, ya que un shell web podría ser uno de los más**.

---

## Desofuscación de Flujo de Control Dinámico (Despachadores JMP/CALL RAX)

Las familias de malware modernas abusan en gran medida de la ofuscación del Grafo de Flujo de Control (CFG): en lugar de un salto/llamada directa, calculan el destino en tiempo de ejecución y ejecutan un `jmp rax` o `call rax`. Un pequeño *despachador* (típicamente nueve instrucciones) establece el objetivo final dependiendo de las banderas `ZF`/`CF` de la CPU, rompiendo completamente la recuperación estática del CFG.

La técnica – presentada por el cargador SLOW#TEMPEST – puede ser derrotada con un flujo de trabajo de tres pasos que solo depende de IDAPython y el emulador de CPU Unicorn.

### 1. Localiza cada salto / llamada indirecta
```python
import idautils, idc

for ea in idautils.FunctionItems(idc.here()):
mnem = idc.print_insn_mnem(ea)
if mnem in ("jmp", "call") and idc.print_operand(ea, 0) == "rax":
print(f"[+] Dispatcher found @ {ea:X}")
```
### 2. Extraer el byte-code del despachador
```python
import idc

def get_dispatcher_start(jmp_ea, count=9):
s = jmp_ea
for _ in range(count):
s = idc.prev_head(s, 0)
return s

start = get_dispatcher_start(jmp_ea)
size  = jmp_ea + idc.get_item_size(jmp_ea) - start
code  = idc.get_bytes(start, size)
open(f"{start:X}.bin", "wb").write(code)
```
### 3. Emúlalo dos veces con Unicorn
```python
from unicorn import *
from unicorn.x86_const import *
import struct

def run(code, zf=0, cf=0):
BASE = 0x1000
mu = Uc(UC_ARCH_X86, UC_MODE_64)
mu.mem_map(BASE, 0x1000)
mu.mem_write(BASE, code)
mu.reg_write(UC_X86_REG_RFLAGS, (zf << 6) | cf)
mu.reg_write(UC_X86_REG_RAX, 0)
mu.emu_start(BASE, BASE+len(code))
return mu.reg_read(UC_X86_REG_RAX)
```
Ejecuta `run(code,0,0)` y `run(code,1,1)` para obtener los objetivos de la rama *falsa* y *verdadera*.

### 4. Parchear un salto / llamada directa
```python
import struct, ida_bytes

def patch_direct(ea, target, is_call=False):
op   = 0xE8 if is_call else 0xE9           # CALL rel32 or JMP rel32
disp = target - (ea + 5) & 0xFFFFFFFF
ida_bytes.patch_bytes(ea, bytes([op]) + struct.pack('<I', disp))
```
Después de aplicar el parche, fuerza a IDA a reanalizar la función para que se restauren el CFG completo y la salida de Hex-Rays:
```python
import ida_auto, idaapi
idaapi.reanalyze_function(idc.get_func_attr(ea, idc.FUNCATTR_START))
```
### 5. Etiquetar llamadas a la API indirectas

Una vez que se conoce el destino real de cada `call rax`, puedes decirle a IDA cuál es para que los tipos de parámetros y los nombres de las variables se recuperen automáticamente:
```python
idc.set_callee_name(call_ea, resolved_addr, 0)  # IDA 8.3+
```
### Beneficios prácticos

* Restaura el CFG real → la descompilación pasa de *10* líneas a miles.
* Permite la referencia cruzada de cadenas y xrefs, haciendo que la reconstrucción del comportamiento sea trivial.
* Los scripts son reutilizables: colócalos en cualquier cargador protegido por el mismo truco.

---

## Referencias

- [Unit42 – Evolving Tactics of SLOW#TEMPEST: A Deep Dive Into Advanced Malware Techniques](https://unit42.paloaltonetworks.com/slow-tempest-malware-obfuscation/)

{{#include ../../banners/hacktricks-training.md}}
