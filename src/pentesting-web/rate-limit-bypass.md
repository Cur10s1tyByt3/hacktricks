# Bypass de L√≠mite de Tasa

{{#include ../banners/hacktricks-training.md}}

## T√©cnicas de Bypass de L√≠mite de Tasa

### Explorando Endpoints Similares

Se deben realizar intentos de ataques de fuerza bruta en variaciones del endpoint objetivo, como `/api/v3/sign-up`, incluyendo alternativas como `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up`, etc.

### Incorporando Caracteres en Blanco en C√≥digo o Par√°metros

Insertar bytes en blanco como `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` en c√≥digo o par√°metros puede ser una estrategia √∫til. Por ejemplo, ajustar un par√°metro a `code=1234%0a` permite extender los intentos a trav√©s de variaciones en la entrada, como agregar caracteres de nueva l√≠nea a una direcci√≥n de correo electr√≥nico para eludir las limitaciones de intentos.

### Manipulando el Origen IP a trav√©s de Encabezados

Modificar encabezados para alterar el origen IP percibido puede ayudar a evadir el l√≠mite de tasa basado en IP. Encabezados como `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, incluyendo el uso de m√∫ltiples instancias de `X-Forwarded-For`, pueden ajustarse para simular solicitudes desde diferentes IPs.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Cambiando Otros Encabezados

Alterar otros encabezados de solicitud como el user-agent y las cookies se recomienda, ya que tambi√©n pueden ser utilizados para identificar y rastrear patrones de solicitud. Cambiar estos encabezados puede prevenir el reconocimiento y el seguimiento de las actividades del solicitante.

### Aprovechando el Comportamiento del API Gateway

Algunos API gateways est√°n configurados para aplicar limitaci√≥n de tasa basada en la combinaci√≥n de endpoint y par√°metros. Al variar los valores de los par√°metros o agregar par√°metros no significativos a la solicitud, es posible eludir la l√≥gica de limitaci√≥n de tasa del gateway, haciendo que cada solicitud parezca √∫nica. Por ejemplo `/resetpwd?someparam=1`.

### Iniciar Sesi√≥n en Tu Cuenta Antes de Cada Intento

Iniciar sesi√≥n en una cuenta antes de cada intento, o cada conjunto de intentos, podr√≠a reiniciar el contador de limitaci√≥n de tasa. Esto es especialmente √∫til al probar funcionalidades de inicio de sesi√≥n. Utilizar un ataque Pitchfork en herramientas como Burp Suite, para rotar credenciales cada pocos intentos y asegurarse de que los redireccionamientos se marquen, puede reiniciar efectivamente los contadores de limitaci√≥n de tasa.

### Utilizando Redes de Proxy

Desplegar una red de proxies para distribuir las solicitudes a trav√©s de m√∫ltiples direcciones IP puede eludir efectivamente los l√≠mites de tasa basados en IP. Al enrutar el tr√°fico a trav√©s de varios proxies, cada solicitud parece originarse de una fuente diferente, diluyendo la efectividad del l√≠mite de tasa.

### Dividiendo el Ataque a Trav√©s de Diferentes Cuentas o Sesiones

Si el sistema objetivo aplica l√≠mites de tasa por cuenta o por sesi√≥n, distribuir el ataque o la prueba a trav√©s de m√∫ltiples cuentas o sesiones puede ayudar a evitar la detecci√≥n. Este enfoque requiere gestionar m√∫ltiples identidades o tokens de sesi√≥n, pero puede distribuir efectivamente la carga para mantenerse dentro de los l√≠mites permitidos.

### Sigue Intentando

Ten en cuenta que incluso si hay un l√≠mite de tasa en su lugar, deber√≠as intentar ver si la respuesta es diferente cuando se env√≠a el OTP v√°lido. En [**esta publicaci√≥n**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), el cazador de bugs descubri√≥ que incluso si se activa un l√≠mite de tasa despu√©s de 20 intentos fallidos al responder con 401, si se envi√≥ el v√°lido se recibi√≥ una respuesta 200.

---

### Abusando de la multiplexi√≥n HTTP/2 y el pipelining de solicitudes (2023-2025)

Las implementaciones modernas de limitadores de tasa frecuentemente cuentan **conexiones TCP** (o incluso solicitudes HTTP/1.1 individuales) en lugar del *n√∫mero de flujos HTTP/2* que contiene una conexi√≥n. Cuando se reutiliza la misma conexi√≥n TLS, un atacante puede abrir cientos de flujos paralelos, cada uno llevando una solicitud separada, mientras que el gateway solo deduce *una* solicitud de la cuota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Si el limitador protege solo `/verify` pero no `/api/v2/verify`, tambi√©n puedes combinar **confusi√≥n de ruta** con multiplexi√≥n HTTP/2 para un *extremadamente* r√°pido ataque de fuerza bruta de OTP o credenciales.

> üêæ  **Consejo:** El [Turbo Intruder](https://portswigger.net/research/turbo-intruder) de PortSwigger admite HTTP/2 y te permite ajustar `maxConcurrentConnections` y `requestsPerConnection` para automatizar este ataque.

### Alias de GraphQL y operaciones por lotes

GraphQL permite al cliente enviar **varias consultas o mutaciones l√≥gicamente independientes en una sola solicitud** al prefijarlas con *alias*. Dado que el servidor ejecuta cada alias pero el limitador de tasa a menudo cuenta solo *una* solicitud, este es un bypass confiable para la limitaci√≥n de inicio de sesi√≥n o restablecimiento de contrase√±a.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Mira la respuesta: exactamente un alias devolver√° 200 OK cuando se golpee el c√≥digo correcto, mientras que los otros est√°n limitados por tasa.

La t√©cnica fue popularizada por la investigaci√≥n de PortSwigger sobre ‚ÄúGraphQL batching & aliases‚Äù en 2023 y ha sido responsable de muchos pagos recientes de recompensas por errores.

### Abuso de *batch* o *bulk* REST endpoints

Algunas APIs exponen endpoints auxiliares como `/v2/batch` o aceptan un **array de objetos** en el cuerpo de la solicitud. Si el limitador se coloca solo frente a los endpoints *legacy*, envolver m√∫ltiples operaciones dentro de una sola solicitud masiva puede eludir completamente la protecci√≥n.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Temporizaci√≥n de la ventana deslizante

Un limitador cl√°sico de token-bucket o leaky-bucket *se reinicia* en un l√≠mite de tiempo fijo (por ejemplo, cada minuto). Si se conoce la ventana (por ejemplo, a trav√©s de mensajes de error como `X-RateLimit-Reset: 27`), realiza el n√∫mero m√°ximo de solicitudes permitidas **justo antes** de que el bucket se reinicie, luego dispara inmediatamente otra r√°faga completa.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Esta simple optimizaci√≥n puede m√°s que duplicar tu rendimiento sin tocar ninguna otra t√©cnica de bypass.

---

## Herramientas

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Herramienta de fuzzing que soporta la aleatorizaci√≥n de encabezados, listas de palabras en fragmentos y rotaci√≥n de proxies round-robin.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Crea autom√°ticamente puntos finales desechables de AWS API Gateway para que cada solicitud provenga de una direcci√≥n IP diferente ‚Äì perfecto para derrotar el estrangulamiento basado en IP.
- **Burp Suite ‚Äì IPRotate + extensi√≥n**: Utiliza un grupo de proxies SOCKS/HTTP (o AWS API Gateway) para rotar la IP de origen de manera transparente durante los ataques de *Intruder* y *Turbo Intruder*.
- **Turbo Intruder (BApp)**: Motor de ataque de alto rendimiento que soporta multiplexi√≥n HTTP/2; ajusta `requestsPerConnection` a 100-1000 para colapsar cientos de solicitudes en una sola conexi√≥n.

## Referencias

- PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù  (2023)  <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (secci√≥n *Connection-based throttling*) (2024)  <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
