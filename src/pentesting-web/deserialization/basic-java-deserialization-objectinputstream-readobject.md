# Deserialización básica de Java con ObjectInputStream readObject

{{#include ../../banners/hacktricks-training.md}}

En este POST se va a explicar un ejemplo utilizando `java.io.Serializable` **y por qué sobrescribir `readObject()` puede ser extremadamente peligroso si el flujo entrante es controlado por un atacante**.

## Serializable

La interfaz `Serializable` de Java (`java.io.Serializable`) es una interfaz de marcador que tus clases deben implementar si van a ser **serializadas** y **deserializadas**. La serialización de objetos en Java (escritura) se realiza con el [`ObjectOutputStream`](http://tutorials.jenkov.com/java-io/objectoutputstream.html) y la deserialización (lectura) se realiza con el [`ObjectInputStream`](http://tutorials.jenkov.com/java-io/objectinputstream.html).

### Recordatorio: ¿Qué métodos se invocan implícitamente durante la deserialización?

1. `readObject()` – lógica de lectura específica de la clase (si está implementada y *privada*).
2. `readResolve()` – puede reemplazar el objeto deserializado por otro.
3. `validateObject()` – a través de callbacks de `ObjectInputValidation`.
4. `readExternal()` – para clases que implementan `Externalizable`.
5. Los constructores **no** se ejecutan – por lo tanto, las cadenas de gadgets dependen exclusivamente de los callbacks anteriores.

Cualquier método en esa cadena que termine invocando datos controlados por un atacante (ejecución de comandos, búsquedas JNDI, reflexión, etc.) convierte la rutina de deserialización en un gadget RCE.

Veamos un ejemplo con una **clase Persona** que es **serializable**. Esta clase **sobrescribe la función readObject**, por lo que cuando **cualquier objeto** de esta **clase** es **deserializado**, esta **función** va a ser **ejecutada**.\
En el ejemplo, la **función readObject** de la clase Persona llama a la función `eat()` de su mascota y la función `eat()` de un Perro (por alguna razón) llama a un **calc.exe**. **Vamos a ver cómo serializar y deserializar un objeto Persona para ejecutar esta calculadora:**

**El siguiente ejemplo es de <https://medium.com/@knownsec404team/java-deserialization-tool-gadgetinspector-first-glimpse-74e99e493649>**
```java
import java.io.Serializable;
import java.io.*;

public class TestDeserialization {
interface Animal {
public void eat();
}
//Class must implements Serializable to be serializable
public static class Cat implements Animal,Serializable {
@Override
public void eat() {
System.out.println("cat eat fish");
}
}
//Class must implements Serializable to be serializable
public static class Dog implements Animal,Serializable {
@Override
public void eat() {
try {
Runtime.getRuntime().exec("calc");
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("dog eat bone");
}
}
//Class must implements Serializable to be serializable
public static class Person implements Serializable {
private Animal pet;
public Person(Animal pet){
this.pet = pet;
}
//readObject implementation, will call the readObject from ObjectInputStream  and then call pet.eat()
private void readObject(java.io.ObjectInputStream stream)
throws IOException, ClassNotFoundException {
pet = (Animal) stream.readObject();
pet.eat();
}
}
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}
public static void main(String[] args) throws Exception {
// Example to call Person with a Dog
Animal animal = new Dog();
Person person = new Person(animal);
GeneratePayload(person,"test.ser");
payloadTest("test.ser");
// Example to call Person with a Cat
//Animal animal = new Cat();
//Person person = new Person(animal);
//GeneratePayload(person,"test.ser");
//payloadTest("test.ser");
}
}
```
### Conclusión (escenario clásico)

Como puedes ver en este ejemplo muy básico, la “vulnerabilidad” aquí aparece porque el método **readObject()** está **llamando a otro código controlado por el atacante**. En cadenas de gadgets del mundo real, miles de clases contenidas en bibliotecas externas (Commons-Collections, Spring, Groovy, Rome, SnakeYAML, etc.) pueden ser abusadas – el atacante solo necesita *uno* gadget alcanzable para obtener ejecución de código.

---

## 2023-2025: ¿Qué hay de nuevo en los ataques de deserialización de Java?

* 2023 – CVE-2023-34040: La deserialización de encabezados de registros de error de Spring-Kafka cuando se habilitan las banderas `checkDeserExWhen*` permitió la construcción arbitraria de gadgets a partir de temas publicados por atacantes. Corregido en 3.0.10 / 2.9.11. ¹
* 2023 – CVE-2023-36480: Suposición de servidor de confianza rota en el cliente Java de Aerospike – las respuestas del servidor malicioso contenían cargas útiles serializadas que fueron deserializadas por el cliente → RCE. ²
* 2023 – CVE-2023-25581: El análisis del atributo de perfil de usuario de `pac4j-core` aceptó blobs Base64 con prefijo `{#sb64}` y los deserializó a pesar de un `RestrictedObjectInputStream`. Actualizar ≥ 4.0.0.
* 2023 – CVE-2023-4528: El servicio JSCAPE MFT Manager (puerto 10880) aceptó objetos Java codificados en XML que llevaron a RCE como root/SYSTEM.
* 2024 – Se añadieron múltiples nuevas cadenas de gadgets a ysoserial-plus(mod) incluyendo clases Hibernate5, TomcatEmbed y SnakeYAML 2.x que eluden algunos filtros antiguos.

## Mitigaciones modernas que deberías implementar

1. **JEP 290 / Filtrado de Serialización (Java 9+)**
*Agregar una lista de permitidos o denegados de clases:*
```bash
# Aceptar solo tus DTOs y java.base, rechazar todo lo demás
-Djdk.serialFilter="com.example.dto.*;java.base/*;!*"
```
Ejemplo programático:
```java
var filter = ObjectInputFilter.Config.createFilter("com.example.dto.*;java.base/*;!*" );
ObjectInputFilter.Config.setSerialFilter(filter);
```
2. **JEP 415 (Java 17+) Fábricas de Filtros Específicos de Contexto** – usar un `BinaryOperator<ObjectInputFilter>` para aplicar diferentes filtros por contexto de ejecución (por ejemplo, por llamada RMI, por consumidor de cola de mensajes).
3. **No exponer `ObjectInputStream` sin procesar a través de la red** – preferir codificaciones JSON/Binarias sin semántica de ejecución de código (Jackson después de deshabilitar `DefaultTyping`, Protobuf, Avro, etc.).
4. **Límites de Defensa en Profundidad** – Establecer longitud máxima de arreglos, profundidad, referencias:
```bash
-Djdk.serialFilter="maxbytes=16384;maxdepth=5;maxrefs=1000"
```
5. **Escaneo continuo de gadgets** – ejecutar herramientas como `gadget-inspector` o `serialpwn-cli` en tu CI para fallar la construcción si un gadget peligroso se vuelve alcanzable.

## Hoja de trucos de herramientas actualizada (2024)

* `ysoserial-plus.jar` – bifurcación comunitaria con > 130 cadenas de gadgets:
```bash
java -jar ysoserial-plus.jar CommonsCollections6 'calc' | base64 -w0
```
* `marshalsec` – sigue siendo la referencia para la generación de gadgets JNDI (LDAP/RMI).
* `gadget-probe` – descubrimiento rápido de gadgets en caja negra contra servicios de red.
* `SerialSniffer` – agente JVMTI que imprime cada clase leída por `ObjectInputStream` (útil para crear filtros).
* **Consejo de detección** – habilitar `-Djdk.serialDebug=true` (JDK 22+) para registrar decisiones de filtro y clases rechazadas.

## Lista de verificación rápida para implementaciones seguras de `readObject()`

1. Haz que el método sea `private` y añade la anotación `@Serial` (ayuda al análisis estático).
2. Nunca llames a métodos proporcionados por el usuario o realices I/O en el método – solo lee campos.
3. Si se necesita validación, realízala **después** de la deserialización, fuera de `readObject()`.
4. Prefiere implementar `Externalizable` y hacer lecturas de campos explícitas en lugar de la serialización predeterminada.
5. Registra un `ObjectInputFilter` endurecido incluso para servicios internos (diseño resistente a compromisos).

## Referencias

1. Aviso de Seguridad de Spring – CVE-2023-34040 Deserialización de Java en Spring-Kafka (Ago 2023)
2. Laboratorio de Seguridad de GitHub – GHSL-2023-044: Deserialización insegura en el cliente Java de Aerospike (Jul 2023)

{{#include ../../banners/hacktricks-training.md}}
