# Basic Java Deserialization with ObjectInputStream readObject

{{#include ../../banners/hacktricks-training.md}}

Dans ce POST, un exemple utilisant `java.io.Serializable` **et pourquoi remplacer `readObject()` peut être extrêmement dangereux si le flux entrant est contrôlé par un attaquant** va être expliqué.

## Serializable

L'interface Java `Serializable` (`java.io.Serializable`) est une interface marqueur que vos classes doivent implémenter si elles doivent être **sérialisées** et **désérialisées**. La sérialisation d'objet Java (écriture) se fait avec le [`ObjectOutputStream`](http://tutorials.jenkov.com/java-io/objectoutputstream.html) et la désérialisation (lecture) se fait avec le [`ObjectInputStream`](http://tutorials.jenkov.com/java-io/objectinputstream.html).

### Rappel : Quelles méthodes sont implicitement invoquées lors de la désérialisation ?

1. `readObject()` – logique de lecture spécifique à la classe (si implémentée et *privée*).
2. `readResolve()` – peut remplacer l'objet désérialisé par un autre.
3. `validateObject()` – via des rappels `ObjectInputValidation`.
4. `readExternal()` – pour les classes implémentant `Externalizable`.
5. Les constructeurs ne sont **pas** exécutés – par conséquent, les chaînes de gadgets s'appuient exclusivement sur les rappels précédents.

Toute méthode dans cette chaîne qui finit par invoquer des données contrôlées par un attaquant (exécution de commande, recherches JNDI, réflexion, etc.) transforme la routine de désérialisation en un gadget RCE.

Voyons un exemple avec une **classe Person** qui est **sérialisable**. Cette classe **surcharge la fonction readObject**, donc lorsque **n'importe quel objet** de cette **classe** est **désérialisé**, cette **fonction** va être **exécutée**.\
Dans l'exemple, la **fonction readObject** de la classe Person appelle la fonction `eat()` de son animal de compagnie et la fonction `eat()` d'un Dog (pour une raison quelconque) appelle un **calc.exe**. **Nous allons voir comment sérialiser et désérialiser un objet Person pour exécuter cette calculatrice :**

**L'exemple suivant est tiré de <https://medium.com/@knownsec404team/java-deserialization-tool-gadgetinspector-first-glimpse-74e99e493649>**
```java
import java.io.Serializable;
import java.io.*;

public class TestDeserialization {
interface Animal {
public void eat();
}
//Class must implements Serializable to be serializable
public static class Cat implements Animal,Serializable {
@Override
public void eat() {
System.out.println("cat eat fish");
}
}
//Class must implements Serializable to be serializable
public static class Dog implements Animal,Serializable {
@Override
public void eat() {
try {
Runtime.getRuntime().exec("calc");
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("dog eat bone");
}
}
//Class must implements Serializable to be serializable
public static class Person implements Serializable {
private Animal pet;
public Person(Animal pet){
this.pet = pet;
}
//readObject implementation, will call the readObject from ObjectInputStream  and then call pet.eat()
private void readObject(java.io.ObjectInputStream stream)
throws IOException, ClassNotFoundException {
pet = (Animal) stream.readObject();
pet.eat();
}
}
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}
public static void main(String[] args) throws Exception {
// Example to call Person with a Dog
Animal animal = new Dog();
Person person = new Person(animal);
GeneratePayload(person,"test.ser");
payloadTest("test.ser");
// Example to call Person with a Cat
//Animal animal = new Cat();
//Person person = new Person(animal);
//GeneratePayload(person,"test.ser");
//payloadTest("test.ser");
}
}
```
### Conclusion (scénario classique)

Comme vous pouvez le voir dans cet exemple très basique, la “vulnérabilité” ici apparaît parce que la méthode **readObject()** **appelle d'autres codes contrôlés par l'attaquant**. Dans les chaînes de gadgets du monde réel, des milliers de classes contenues dans des bibliothèques externes (Commons-Collections, Spring, Groovy, Rome, SnakeYAML, etc.) peuvent être abusées – l'attaquant n'a besoin que d'*un* gadget accessible pour obtenir une exécution de code.

---

## 2023-2025 : Quoi de neuf dans les attaques de désérialisation Java ?

* 2023 – CVE-2023-34040 : La désérialisation des en-têtes d'enregistrement d'erreur de Spring-Kafka lorsque les drapeaux `checkDeserExWhen*` sont activés a permis la construction de gadgets arbitraires à partir de sujets publiés par l'attaquant. Corrigé dans 3.0.10 / 2.9.11. ¹
* 2023 – CVE-2023-36480 : L'hypothèse de serveur de confiance du client Java Aerospike a été rompue – les réponses du serveur malveillant contenaient des charges utiles sérialisées qui ont été désérialisées par le client → RCE. ²
* 2023 – CVE-2023-25581 : L'analyse des attributs de profil utilisateur de `pac4j-core` a accepté des blobs Base64 préfixés par `{#sb64}` et les a désérialisés malgré un `RestrictedObjectInputStream`. Mise à niveau ≥ 4.0.0.
* 2023 – CVE-2023-4528 : Le service JSCAPE MFT Manager (port 10880) a accepté des objets Java encodés en XML menant à RCE en tant que root/SYSTEM.
* 2024 – Plusieurs nouvelles chaînes de gadgets ont été ajoutées à ysoserial-plus(mod) y compris les classes Hibernate5, TomcatEmbed et SnakeYAML 2.x qui contournent certains anciens filtres.

## Atténuations modernes que vous devriez déployer

1. **JEP 290 / Filtrage de sérialisation (Java 9+)**
*Ajoutez une liste d'autorisation ou de refus de classes :*
```bash
# Accepter uniquement vos DTO et java.base, rejeter tout le reste
-Djdk.serialFilter="com.example.dto.*;java.base/*;!*"
```
Exemple programmatique :
```java
var filter = ObjectInputFilter.Config.createFilter("com.example.dto.*;java.base/*;!*" );
ObjectInputFilter.Config.setSerialFilter(filter);
```
2. **JEP 415 (Java 17+) Usines de filtres spécifiques au contexte** – utilisez un `BinaryOperator<ObjectInputFilter>` pour appliquer différents filtres par contexte d'exécution (par exemple, par appel RMI, par consommateur de file de messages).
3. **Ne pas exposer de `ObjectInputStream` brut sur le réseau** – préférez les encodages JSON/Binaire sans sémantique d'exécution de code (Jackson après avoir désactivé `DefaultTyping`, Protobuf, Avro, etc.).
4. **Limites de défense en profondeur** – Définir la longueur maximale des tableaux, la profondeur, les références :
```bash
-Djdk.serialFilter="maxbytes=16384;maxdepth=5;maxrefs=1000"
```
5. **Analyse continue des gadgets** – exécutez des outils tels que `gadget-inspector` ou `serialpwn-cli` dans votre CI pour échouer la construction si un gadget dangereux devient accessible.

## Fiche de triche d'outils mise à jour (2024)

* `ysoserial-plus.jar` – fork communautaire avec > 130 chaînes de gadgets :
```bash
java -jar ysoserial-plus.jar CommonsCollections6 'calc' | base64 -w0
```
* `marshalsec` – reste la référence pour la génération de gadgets JNDI (LDAP/RMI).
* `gadget-probe` – découverte rapide de gadgets en boîte noire contre les services réseau.
* `SerialSniffer` – agent JVMTI qui imprime chaque classe lue par `ObjectInputStream` (utile pour créer des filtres).
* **Astuce de détection** – activez `-Djdk.serialDebug=true` (JDK 22+) pour enregistrer les décisions de filtre et les classes rejetées.

## Liste de contrôle rapide pour des implémentations sécurisées de `readObject()`

1. Rendez la méthode `private` et ajoutez l'annotation `@Serial` (aide à l'analyse statique).
2. Ne jamais appeler des méthodes fournies par l'utilisateur ou effectuer des E/S dans la méthode – ne lire que des champs.
3. Si une validation est nécessaire, effectuez-la **après** la désérialisation, en dehors de `readObject()`.
4. Préférez implémenter `Externalizable` et effectuez des lectures de champs explicites au lieu de la sérialisation par défaut.
5. Enregistrez un `ObjectInputFilter` durci même pour les services internes (conception résiliente aux compromissions).

## Références

1. Avis de sécurité Spring – CVE-2023-34040 Désérialisation Java dans Spring-Kafka (août 2023)
2. GitHub Security Lab – GHSL-2023-044 : Désérialisation non sécurisée dans le client Java Aerospike (juillet 2023)

{{#include ../../banners/hacktricks-training.md}}
