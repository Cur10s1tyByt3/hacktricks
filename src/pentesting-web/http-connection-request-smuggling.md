# HTTP Connection Request Smuggling

{{#include ../banners/hacktricks-training.md}}

**Esta página resume, amplía y actualiza** la investigación seminal de PortSwigger sobre [Browser-Powered Desync Attacks](https://portswigger.net/research/browser-powered-desync-attacks) y el trabajo posterior sobre el abuso del estado de conexión HTTP/2. Se centra en vulnerabilidades donde **un origen se determina solo una vez por conexión TCP/TLS**, lo que permite a un atacante “smuggle” solicitudes a un host interno diferente una vez que se establece el canal.

## Connection-State Attacks <a href="#state" id="state"></a>

### First-request Validation

Al enrutar solicitudes, los proxies inversos pueden depender del encabezado **Host** (o **:authority** en HTTP/2) para determinar el servidor de back-end de destino, a menudo confiando en una lista blanca de hosts que tienen acceso permitido. Sin embargo, existe una vulnerabilidad en varios proxies donde la lista blanca se **aplica solo en la primera solicitud de una conexión**. En consecuencia, los atacantes pueden acceder a hosts virtuales internos enviando primero una solicitud permitida y luego reutilizando la misma conexión subyacente:
```http
GET / HTTP/1.1
Host: allowed-external-host.example

GET /admin HTTP/1.1
Host: internal-only.example
```
### Enrutamiento de la primera solicitud

Muchos proxies inversos HTTP/1.1 mapean una conexión saliente a un grupo de back-end **basándose exclusivamente en la primera solicitud que reenvían**. Todas las solicitudes subsiguientes enviadas a través del mismo socket de front-end se reutilizan silenciosamente, independientemente de su encabezado Host. Esto se puede combinar con ataques clásicos de [encabezado Host](https://portswigger.net/web-security/host-header) como el envenenamiento de restablecimiento de contraseña o [envenenamiento de caché web](https://portswigger.net/web-security/web-cache-poisoning) para obtener acceso similar a SSRF a otros hosts virtuales:
```http
GET / HTTP/1.1
Host: public.example

POST /pwreset HTTP/1.1
Host: private.internal
```
> [!TIP]
> En Burp Suite Professional ≥2022.10 puedes habilitar **HTTP Request Smuggler → Connection-state probe** para detectar automáticamente estas debilidades.

---

## NUEVO en 2023-2025 – Abuso de Coalescencia de Conexiones HTTP/2/3

Los navegadores modernos **coalescen** rutinariamente las solicitudes HTTP/2 y HTTP/3 en una sola conexión TLS cuando el certificado, el protocolo ALPN y la dirección IP coinciden. Si un front-end solo autoriza la primera solicitud, cada solicitud coalescida subsiguiente hereda esa autorización – **incluso si el Host/:authority cambia**.

### Escenario de explotación
1. El atacante controla `evil.com`, que se resuelve en el mismo nodo de borde de CDN que el objetivo `internal.company`.
2. El navegador de la víctima ya tiene una conexión HTTP/2 abierta a `evil.com`.
3. El atacante incrusta una `<img src="https://internal.company/…">` oculta en su página.
4. Debido a que los parámetros de conexión coinciden, el navegador reutiliza la conexión TLS **existente** y multiplexa la solicitud para `internal.company`.
5. Si el CDN/router solo validó la primera solicitud, el host interno queda expuesto.

Los PoCs para Chrome/Edge/Firefox están disponibles en la charla de James Kettle *“HTTP/2: The Sequel is Always Worse”* (Black Hat USA 2023).

### Herramientas
* **Burp Suite 2023.12** introdujo un punto de inserción experimental **HTTP/2 Smuggler** que intenta automáticamente la coalescencia y técnicas TE/CL.
* **smuggleFuzz** (https://github.com/microsoft/smugglefuzz) – Un marco de Python lanzado en 2024 para forzar vectores de desincronización front-end/back-end a través de HTTP/2 y HTTP/3, incluyendo permutaciones de estado de conexión.

### Mitigaciones
* Siempre **re-validar Host/:authority en cada solicitud**, no solo en la creación de la conexión.
* Deshabilitar o restringir estrictamente la **coalescencia de origen** en capas de CDN/balancer de carga (por ejemplo, `http2_origin_cn` apagado en NGINX).
* Desplegar certificados o direcciones IP separadas para nombres de host internos y externos para que el navegador no pueda coalescernos legalmente.
* Preferir **connection: close** o `proxy_next_upstream` después de cada solicitud donde sea práctico.

---

## Casos del Mundo Real (2022-2025)

| Año | Componente | CVE | Notas |
|------|-----------|-----|-------|
| 2022 | AWS Application Load Balancer | – | El encabezado Host solo se validó en la primera solicitud; solucionado parcheando el motor de reglas (divulgado por SecurityLabs). |
| 2023 | Apache Traffic Server < 9.2.2 | CVE-2023-39852 | Permitió el smuggling de solicitudes a través de la reutilización de conexiones HTTP/2 cuando se configuró `CONFIG proxy.config.http.parent_proxy_routing_enable`. |
| 2024 | Envoy Proxy < 1.29.0 | CVE-2024-2470 | Validación inadecuada de :authority después del primer stream habilitó el smuggling de solicitudes entre inquilinos en mallas compartidas. |

---

## Hoja de Trucos para Detección

1. Envía dos solicitudes en la **misma** conexión TCP/TLS con diferentes encabezados Host o :authority.
2. Observa si la segunda respuesta proviene del primer host (seguro) o del segundo host (vulnerable).
3. En Burp: `Repeat → keep-alive → Send → Follow`.
4. Al probar HTTP/2, abre un stream **dedicado** (ID 1) para un host benigno, luego multiplexa un segundo stream (ID 3) a un host interno y busca una respuesta.

---

## Referencias

* PortSwigger Research – *HTTP/2: The Sequel is Always Worse* (Black Hat USA 2023)
* Aviso de Seguridad de Envoy CVE-2024-2470 – Validación inadecuada de autoridad

{{#include ../banners/hacktricks-training.md}}
